<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础知识总结]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F25%2FJava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本人学习java时，做的java基础知识总结：写代码： 1，明确需求。我要做什么？ 2，分析思路。我要怎么做？1,2,3。 3，确定步骤。每一个思路部分用到哪些语句，方法，和对象。 4，代码实现。用具体的java语言代码把思路体现出来。 学习新技术的四点： 1，该技术是什么？ 2，该技术有什么特点(使用注意)： 3，该技术怎么使用。demo 4，该技术什么时候用？test。 -———————————————————————————————- 一：java概述： 1991 年Sun公司的James Gosling（詹姆斯&middot;高斯林）等人开始开发名称为 Oak 的语言，希望用于控制嵌入在有线电视交换盒、PDA等的微处理器； 1994年将Oak语言更名为Java； Java**的三种技术架构:** JAVAEE**：**Java Platform Enterprise Edition，开发企业环境下的应用程序，主要针对web程序开发； JAVASE**：**Java Platform Standard Edition，完成桌面应用程序的开发，是其它两者的基础； JAVAME**：**Java Platform Micro Edition，开发电子消费产品和嵌入式设备，如手机中的程序； 1**，JDK：Java Development Kit，**java的开发和运行环境，java的开发工具和jre。 2**，JRE：Java Runtime Environment，**java程序的运行环境，java运行的所需的类库+JVM(java虚拟机)。 3**，配置环境变量：**让java jdk\bin目录下的工具，可以在任意目录下运行，原因是，将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。 环境变量的配置： ​ 1）：永久配置方式：JAVA_HOME=%安装路径%\Java\jdk ​ path=%JAVA_HOME%\bin ​ 2）：临时配置方式：set path=%path%;C:\Program Files\Java\jdk\bin 特点：系统默认先去当前路径下找要执行的程序，如果没有，再去path中设置的路径下找。 classpath**的配置:** ​ 1）：永久配置方式：classpath=.;c:\;e:\ ​ 2）：临时配置方式：set classpath=.;c:\;e:\ 注意：在定义classpath环境变量时，需要注意的情况 如果没有定义环境变量classpath，java启动jvm后，会在当前目录下查找要运行的类文件； 如果指定了classpath，那么会在指定的目录下查找要运行的类文件。 还会在当前目录找吗？两种情况： ​ 1）：如果classpath的值结尾处有分号，在具体路径中没有找到运行的类，会默认在当前目录再找一次。 ​ 2）：如果classpath的值结果出没有分号，在具体的路径中没有找到运行的类，不会再当前目录找。 ​ 一般不指定分号，如果没有在指定目录下找到要运行的类文件，就报错，这样可以调试程序。 4**，javac命令和java命令做什么事情呢？** ​ 要知道java是分两部分的：一个是编译，一个是运行。 ​ javac**：**负责的是编译的部分，当执行javac时，会启动java的编译器程序。对指定扩展名的.java文件进行编译。 生成了jvm可以识别的字节码文件。也就是class文件，也就是java的运行程序。 ​ java**：**负责运行的部分.会启动jvm.加载运行时所需的类库,并对class文件进行执行. ​ 一个文件要被执行,必须要有一个执行的起始点,这个起始点就是main函数. -——————————————————————————————— 二：java语法基础： 1**，关键字：**其实就是某种语言赋予了特殊含义的单词。 ​ 保留字：其实就是还没有赋予特殊含义，但是准备日后要使用过的单词。 2**，标示符：**其实就是在程序中自定义的名词。比如类名，变量名，函数名。包含 0-9、a-z、$、_ ； ​ 注意： ​ 1**），数字不可以开头。** ​ 2**），不可以使用关键字。** 3**，常量：**是在程序中的不会变化的数据。 4**，变量：**其实就是内存中的一个存储空间，用于存储常量数据。 ​ 作用：方便于运算。因为有些数据不确定。所以确定该数据的名词和存储空间。 ​ 特点：变量空间可以重复使用。 什么时候定义变量？只要是数据不确定的时候，就定义变量。 变量空间的开辟需要什么要素呢？ ​ 1，这个空间要存储什么数据？数据类型。 ​ 2，这个空间叫什么名字啊？变量名称。 ​ 3，这个空间的第一次的数据是什么？ 变量的初始化值。 变量的作用域和生存期: 变量的作用域： ​ 作用域从变量定义的位置开始，到该变量所在的那对大括号结束； 生命周期： ​ 变量从定义的位置开始就在内存中活了； ​ 变量到达它所在的作用域的时候就在内存中消失了； 数据类型： ​ 1**）：基本数据类型**：byte、short、int、long、float、double、char、boolean ​ 2**）：引用数据类型**: 数组、类、接口。 级别从低到高为：byte,char,short(这三个平级)–&gt;int–&gt;float–&gt;long–&gt;double 自动类型转换：从低级别到高级别，系统自动转的； 强制类型转换：什么情况下使用?把一个高级别的数赋给一个别该数的级别低的变量； 运算符号： ​ 1）、算术运算符。 ​ + - / % *%:任何整数模2不是0就是1，所以只要改变被模数就可以实现开关运算。 ​ +:连接符。 ​ ++,– ​ 2）、赋值运算符。 ​ = += -= *= /= %= ​ 3）、比较运算符。 ​ 特点：该运算符的特点是：运算完的结果，要么是true，要么是false。 ​ 4）、逻辑运算符。 ​ &amp; | ^ ! &amp;&amp; || ​ 逻辑运算符除了 ! 外都是用于连接两个boolean类型表达式。 ​ &amp;: 只有两边都为true结果是true。否则就是false。 ​ |:只要两边都为false结果是false，否则就是true ​ ^:异或：和或有点不一样。 ​ 两边结果一样，就为false。 ​ 两边结果不一样，就为true. ​ &amp; 和 &amp;&amp;区别： &amp; ：无论左边结果是什么，右边都参与运算。 ​ &amp;&amp;:**短路与**，如果左边为false，那么右边不参数与运算。 ​ | 和|| 区别：|：两边都运算。 ​ ||**：短路或**，如果左边为true，那么右边不参与运算。 ​ 5）、位运算符:用于操作二进制位的运算符。 ​ &amp; | ^ ​ &lt;&lt; &gt;&gt; &gt;&gt;&gt;(无符号右移) ​ 练习：对两个变量的数据进行互换。不需要第三方变量。 ​ int a = 3,b = 5;–&gt;b = 3,a = 5; ​ a = a + b; a = 8; ​ b = a - b; b = 3; ​ a = a - b; a = 5; ​ a = a ^ b;// ​ b = a ^ b;//b = a ^ b ^ b = a ​ a = a ^ b;//a = a ^ b ^ a = b; ​ 练习：高效的算出 2*8 = 2&lt;&lt;3; 5**，语句。** ​ If switch do while while for ​ 这些语句什么时候用？ ​ 1）、当判断固定个数的值的时候，可以使用if，也可以使用switch。 ​ 但是建议使用switch，效率相对较高。 switch(变量){ case 值:要执行的语句;break; … default:要执行的语句; } 工作原理：用小括号中的变量的值依次和case后面的值进行对比，和哪个case后面的值相同了 ​ 就执行哪个case后面的语句，如果没有相同的则执行default后面的语句； 细节：1）：break是可以省略的，如果省略了就一直执行到遇到break为止； ​ 2）：switch 后面的小括号中的变量应该是byte,char,short,int四种类型中的一种； ​ 3）：default可以写在switch结构中的任意位置；如果将default语句放在了第一行，则不管expression与case中的value是否匹配，程序会从default开始执行直到第一个break出现。 ​ 2）、当判断数据范围，获取判断运算结果boolean类型时，需要使用if。 ​ 3）、当某些语句需要执行很多次时，就用循环结构。 ​ while和for可以进行互换。 ​ 区别在于：如果需要定义变量控制循环次数。建议使用for。因为for循环完毕，变量在内存中释放。 break:作用于switch ，和循环语句，用于跳出，或者称为结束。 break语句单独存在时，下面不要定义其他语句，因为执行不到，编译会失败。当循环嵌套时，break只跳出当前所在循环。要跳出嵌套中的外部循环，只要给循环起名字即可，这个名字称之为标号。 continue:只作用于循环结构，继续循环用的。 作用：结束本次循环，继续下次循环。该语句单独存在时，下面不可以定义语句，执行不到。 6**，函 数：**为了提高代码的复用性，可以将其定义成一个单独的功能，该功能的体现就是java中的函数。函数就是体现之一。 java**中的函数的定义格式：** ​ 修饰符 返回值类型 函数名(参数类型 形式参数1，参数类型 形式参数1，…){ ​ 执行语句； ​ return 返回值； ​ } 当函数没有具体的返回值时，返回的返回值类型用void关键字表示。 如果函数的返回值类型是void时，return语句可以省略不写的，系统会帮你自动加上。 return**的作用：**结束函数。结束功能。 如何定义一个函数？ ​ 函数其实就是一个功能，定义函数就是实现功能，通过两个明确来完成： ​ 1）、明确该功能的运算完的结果，其实是在明确这个函数的返回值类型。 ​ 2）、在实现该功能的过程中是否有未知内容参与了运算，其实就是在明确这个函数的参数列表(参数类型&amp;参数个数)。 函数的作用： 1）、用于定义功能。 2）、用于封装代码提高代码的复用性。 注意：函数中只能调用函数，不能定义函数。 主函数： ​ 1）、保证该类的独立运行。 ​ 2）、因为它是程序的入口。 ​ 3）、因为它在被jvm调用。 函数定义名称是为什么呢？ 答：1）、为了对该功能进行标示，方便于调用。 ​ 2）、为了通过名称就可以明确函数的功能，为了增加代码的阅读性。 重载的定义是：在一个类中，如果出现了两个或者两个以上的同名函数，只要它们的参数的个数，或者参数的类型不同，即可称之为该函数重载了。 如何区分重载：当函数同名时，只看参数列表。和返回值类型没关系。 7**，数 组：用于存储同一类型数据的一个容器。好处：**可以对该容器中的数据进行编号，从0开始。数组用于封装数据，就是一个具体的实体。 如何在java中表现一个数组呢？两种表现形式。 1）、元素类型[] 变量名 = new 元素类型[元素的个数]； 2）、元素类型[] 变量名 = {元素1，元素2…}； 元素类型[] 变量名 = new 元素类型[]{元素1，元素2…}； -——————————————————– //**二分查找法。必须有前提：数组中的元素要有序。** ​ public static int halfSeach_2(int[] arr,int key){ ​ int min,max,mid; ​ min = 0; ​ max = arr.length-1; ​ mid = (max+min)&gt;&gt;1; //(max+min)/2; ​ while(arr[mid]!=key){ ​ if(key&gt;arr[mid]){ ​ min = mid + 1; ​ } ​ else if(key&lt;arr[mid]) ​ max = mid - 1; ​ if(max&lt;min) ​ return -1; ​ mid = (max+min)&gt;&gt;1; ​ } ​ return mid; ​ } -——————————————————– java**分了5片内存。** 1：寄存器。2：本地方法区。3：方法区。4：栈。5：堆。 栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )； ​ 只要数据运算完成所在的区域结束，该数据就会被释放。 堆：用于存储数组和对象，也就是实体。啥是实体啊？就是用于封装多个数据的。 1：每一个实体都有内存首地址值。 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。 3：垃圾回收机制。 -——————————————————————————————— 三：面向对象：★★★★★ 特点：**1**：将复杂的事情简单化。 2**：面向对象将以前的过程中的执行者，变成了指挥者。** 3**：面向对象这种思想是符合现在人们思考习惯的一种思想。** 过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。 匿名对象使用场景： 1：当对方法只进行一次调用的时候，可以使用匿名对象。 2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。 在类中定义其实都称之为成员。成员有两种： 1：成员变量：其实对应的就是事物的属性。 2：成员函数：其实对应的就是事物的行为。 所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。 private int age;//**私有的访问权限最低，只有在本类中的访问有效。** 注意：私有仅仅是封装的一种体现形式而已。 私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。 好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。 总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。 这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。 类中怎么没有定义主函数呢？ 注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。 主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。 成员变量和局部变量的区别： 1**：成员变量直接定义在类中。** 局部变量定义在方法中，参数上，语句中。 2**：成员变量在这个类中有效。** 局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。 3**：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。** 局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。 构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。 特点： 1：该函数的名称和所在类的名称相同。 2：不需要定义返回值类型。 3：该函数没有具体的返回值。 记住：所有对象创建时，都需要初始化才可以使用。 注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。 一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。 构造函数和一般函数有什么区别呢？ 1：两个函数定义格式不同。 2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 ​ 一般函数，是对象创建后，需要调用才执行，可以被调用多次。 什么时候使用构造函数呢？ 分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。 构造代码块和构造函数有什么区别？ 构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块，只要对象一建立，就会调用这个代码块。 构造函数：是给与之对应的对象进行初始化，它具有针对性。 “Person p = new Person();” 创建一个对象都在内存中做了什么事情？ 1：先将硬盘上指定位置的Person.class文件加载进内存。 2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。 3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new 4：在该实体空间中进行属性的空间分配，并进行了默认初始化。 5：对空间中的属性进行显示初始化。 6：进行实体的构造代码块初始化。 7：调用该实体对应的构造函数，进行构造函数初始化。（） 8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象) -——————————————————————————————- 封 装**（面向对象特征之一）**：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 好处：将变化隔离；便于使用；提高重用性；安全性。 封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。 This**：**代表对象，就是所在函数所属对象的引用。 this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。 开发时，什么时候使用this呢？ 在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。 this 还可以用于构造函数间的调用。 调用格式：this(实际参数)； this对象后面跟上 . 调用的是成员属性和成员方法(一般方法)； this对象后面跟上 () 调用的是本类中的对应参数的构造函数。 注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。**否则编译失败。** static**：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。** 特点： 1，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰。 2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。 3，静态随着类的加载而加载，而且优先于对象存在。 弊端： 1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。 2，静态方法只能访问静态成员，不可以访问非静态成员。 因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。 3，静态方法中不能使用this，super关键字。 因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。 4，主函数是静态的。 什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？ 成员分两种： 1**，成员变量。（数据共享时静态化**） 该成员变量的数据是否是所有对象都一样： 如果是，那么该变量需要被静态修饰，因为是共享的数据。 如果不是，那么就说这是对象的特有数据，要存储到对象中。 2**，成员函数。（方法中没有调用特有数据时就定义成静态**） ​ 如果判断成员函数是否需要被静态修饰呢？ ​ 只要参考，该函数内是否访问了对象中的特有数据： ​ 如果有访问特有数据，那方法不能被静态修饰。 ​ 如果没有访问过特有数据，那么这个方法需要被静态修饰。 成员变量和静态变量的区别： 1，成员变量所属于对象，所以也称为实例变量。 静态变量所属于类，所以也称为类变量。 2，成员变量存在于堆内存中。 静态变量存在于方法区中。 3，成员变量随着对象创建而存在，随着对象被回收而消失。 静态变量随着类的加载而存在，随着类的消失而消失。 4，成员变量只能被对象所调用。 静态变量可以被对象调用，也可以被类名调用。 所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。 静态的注意：静态的生命周期很长。 静态代码块：就是一个有静态关键字标示的一个代码块区域，定义在类中。 作用：可以完成类的初始化，静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。 Public**：**访问权限最大。 static**：**不需要对象，直接类名即可。 void**：**主函数没有返回值。 Main**：**主函数特定的名称。 (String[] args)**：**主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。 jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。 静态代码块、构造代码块、构造函数同时存在时的执行顺序：**静态代码块 &agrave; 构造代码块 &agrave; 构造函数；** 生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java /** //格式 *类描述 *@author 作者名 *@version 版本号 */ /** *方法描述 *@param 参数描述 *@return 返回值描述 */ -——————————————————————————————– 设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 java中有23种设计模式： 单例设计模式：★★★★★ 解决的问题：保证一个类在内存中的对象唯一性。 比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。 Runtime()**方法就是单例设计模式进行设计的。** 如何保证对象唯一性呢？ 思想： 1，不让其他程序创建该类对象。 2，在本类中创建一个本类对象。 3，对外提供方法，让其他程序获取这个对象。 步骤： 1**，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；** 2**，就在类中创建一个本类的对象；** 3**，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）** 代码体现： 1**，私有化构造函数；** 2**，创建私有并静态的本类对象；** 3**，定义公有并静态的方法，返回该对象。** -——————————————– //饿汉式 class Single{ ​ private Single(){} //私有化构造函数。 private static Single s = new Single(); //创建私有并静态的本类对象。 ​ public static Single getInstance(){ //定义公有并静态的方法，返回该对象。 ​ return s; ​ } } -——————————————– //懒汉式:延迟加载方式。 class Single2{ ​ private Single2(){} private static Single2 s = null; ​ public static Single2 getInstance(){ ​ if(s==null) ​ s = new Single2(); ​ return s; ​ } } -———————————————————————————————— 继 承**（面向对象特征之一）** 好处： 1**：提高了代码的复用性。** 2**：让类与类之间产生了关系，提供了另一个特征多态的前提。** 父类的由来：其实是由多个类不断向上抽取共性内容而来的。 java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。 单继承：一个类只能有一个父类。 多继承：一个类可以有多个父类。 为什么不支持多继承呢？ 因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。 但是java支持多重继承。A继承B B继承C C继承D。 多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。 所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。 简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。 子父类出现后，类中的成员都有了哪些特点： 1**：成员变量。** ​ 当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。 ​ 如果想要调用父类中的属性值，需要使用一个关键字：super ​ This**：**代表是本类类型的对象引用。 ​ Super**：**代表是子类所属的父类中的内存空间引用。 ​ 注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。 2**：成员函数。** 当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写) 什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。 3**：构造函数。** 发现子类构造函数运行时，先运行了父类的构造函数。为什么呢? 原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super(); super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。 为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?) 因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。 注意：**子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();** 如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。 如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。 问题：super()和this()是否可以同时出现的构造函数中。 两个语句只能有一个定义在第一行，所以只能出现其中一个。 super()**或者this():为什么一定要定义在第一行？** 因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。 继承的细节： 什么时候使用继承呢？ 当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。 英文书中，所属关系：” is a “ 注意：不要仅仅为了获取其他类中的已有成员进行继承。 所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。 细节二： 在方法覆盖时，注意两点： 1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。 2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖) 继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。 这时如何解决问题呢？介绍一个关键字，final:最终。 final**特点：** 1**：这个关键字是一个修饰符，可以修饰类，方法，变量。** 2**：被final修饰的类是一个最终类，不可以被继承。** 3**：被final修饰的方法是一个最终方法，不可以被覆盖。** 4**：被final修饰的变量是一个常量，只能赋值一次。** ​ 其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。 ​ 不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。 抽象类: abstract 抽象：不具体，看不明白。抽象类表象体现。 在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。 抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。 抽象类的特点： 1**：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。** 2**：抽象方法只定义方法声明，并不定义方法实现。** 3**：抽象类不可以被创建对象(实例化)。** 4**：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。** 抽象类的细节： 1**：抽象类中是否有构造函数？有，用于给子类对象进行初始化。** 2**：抽象类中是否可以定义非抽象方法？** ​ 可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。 3**：抽象关键字abstract和哪些不可以共存？final , private , static** 4**：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。** -———————————————————————————————- 模板方法设计模式： 解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 abstract class GetTime{ ​ public final void getTime(){ //**此功能如果不需要复写，可加final限定** ​ long start = System.currentTimeMillis(); ​ code(); //**不确定的功能部分，提取出来，通过抽象方法实现** ​ long end = System.currentTimeMillis(); ​ System.out.println(“毫秒是：”+(end-start)); ​ } ​ public abstract void code(); //**抽象不确定的功能，让子类复写实现** } class SubDemo extends GetTime{ ​ public void code(){ //**子类复写功能方法** ​ for(int y=0; y&lt;1000; y++){ ​ System.out.println(“y”); ​ } ​ } }]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建+主题优化+插件配置+常用操作+错误分析]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F15%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2B%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2B%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[如果你和我一样是小白，那么恭喜你！ 你马上就会有一个跟我一样的博客啦！ 博客搭建准备环境 Node.js 下载，并安装。详细步骤：www.simon96.online/2018/11/10/… Git 下载，并安装。详细步骤：www.simon96.online/2018/11/10/… 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install复制代码 新建完成后，在路径下，会产生这些文件和文件夹： 123456789.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes复制代码 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 ​ 路径为&lt;folder&gt;\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 ​ 路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 浏览器访问网址： http://localhost:4000/ 至此，您的Hexo博客已经搭建在本地。 实施方案方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 12$ npm install hexo-deployer-git --save复制代码 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 12$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;复制代码 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@github.com$ yes复制代码 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master复制代码 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为： 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@git.coding.net$ yes复制代码 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 12345678910# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master复制代码 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 域名解析 添加 CNAME 记录指向 .coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 123$ yum -y update$ yum install -y git nginx复制代码 Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 1234cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/复制代码 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 12vim /usr/local/hexo/index.html复制代码 添加以下代码，并保存。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;复制代码 2.3. 配置 Nginx 服务器 12vim /etc/nginx/nginx.conf复制代码 修改server_name和root： 1234567server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 复制代码 2.4. 启动nginx服务； 12service nginx start复制代码 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 1234cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/复制代码 3.2. Git 初始化裸库。 123cd hexoRepo/git init --bare hexo.git复制代码 3.3. 创建 Git 钩子(hook)。 12vim /usr/local/hexoRepo/hexo.git/hooks/post-receive复制代码 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 1234#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f复制代码 3.5. 保存并退出后, 给该文件添加可执行权限。 12chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive复制代码 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 12$ npm install hexo-deployer-git --save复制代码 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 12$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;复制代码 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@github.com$ yes复制代码 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master复制代码 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt;复制代码 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\themes*\layout_partials\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 12345678body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125;复制代码 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 123456789@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;);&#125;.site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important;&#125;复制代码 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 123456// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px复制代码 网站标题栏背景颜色1234.site-meta &#123; background: $blue; //修改为自己喜欢的颜色&#125;复制代码 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 12345678// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125;复制代码 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 之前插入代码： 1234567891011&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;复制代码 写文章时加上password: *： 123456---title: 2018date: 2018-10-25 16:10:03password: 123456---复制代码 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。 代码如下： 123!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);复制代码 在\themes\*\layout\_layout.swig文件末尾添加： 1234&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;复制代码 静态资源压缩在站点目录下： 12$ npm install gulp -g复制代码 安装gulp插件： 123456npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save复制代码 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]);复制代码 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 1234hexo ggulphexo d复制代码 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 12permalink: :category/:title/复制代码 博文置顶 安装插件 npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 1234567---title: 2018date: 2018-10-25 16:10:03top: 10---复制代码 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 1234567 &#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125;复制代码 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 123456789// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;复制代码 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 123456# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true复制代码 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 123$ cd &lt;站点目录&gt;$ hexo new page categories复制代码 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 123&#123;% include &apos;_custom/google_ad.swig&apos; %&#125;复制代码 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 12345678&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_ad.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125;复制代码 等待审核通过。如果失败，可再次申请。 添加萌萌哒 安装插件 123npm install --save hexo-helper-live2d复制代码 复制你喜欢的模型名字： Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true复制代码 建配置文件 4.1. 在站点目录下建文件夹live2d_models， 4.2. 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 4.3. 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 插件配置以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。 评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 Valine1.1. 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 1.3. 运行hexo g&amp;&amp;hexo d推送到博客。 来必力/livere2.1. 登陆 来必力 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件_config.yml 畅言3.1.获取APP ID 和 APP Key 请先登录或注册 畅言, 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的APP ID和APP Key了。 3.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 3.3. 运行hexo g&amp;&amp;hexo d推送到博客。 gitment4.1. 安装插件： npm i –save gitment 4.2. 申请应用 在New OAuth App为你的博客应用一个密钥: 123456Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址复制代码 4.3. 配置 编辑主题配置文件themes/*/_config.yml: 1234567891011121314151617# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro复制代码 Disqus编辑 主题配置文件themes/*/_config.yml， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 123456disqus: enable: false shortname: count: true复制代码 数据统计与分析 推荐指数 优点 缺点 不蒜子 4 可直接将访问次数显示在您在网页上（也可不显示） 只计数 百度统计 3 收录慢 不蒜子编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可。 当enable: true时，代表开启全局开关。 若site_uv（本站访客数）、site_pv（本站访客数）、page_pv（本文总阅读量）的值均为false时，不蒜子仅作记录而不会在页面上显示。 注意： 123不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！复制代码 解决办法： 找到主题调用不蒜子的swig文件。一般在”\themes*\layout_third-party\analytics\busuanzi-counter.swig” 更改域名 123456把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;复制代码 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图： 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 1234# 百度分享服务baidushare: true复制代码 need-more-share2编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 1234needmoreshare2: enable: true复制代码 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 123$ npm install hexo-generator-searchdb --save复制代码 编辑 站点配置文件，新增以下内容到任意位置： 1234567search: path: search.xml field: post format: html limit: 10000复制代码 编辑 主题配置文件，启用本地搜索功能： 12345# Local searchlocal_search: enable: true复制代码 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error1234JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s复制代码 参数中包含冒号，请用加引号，如Last updated: %s 1234JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated：&quot;Last updated: %s&quot;复制代码 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” EMFILE Error123Error: EMFILE, too many open files复制代码 生成大量的文件时，可能遇到EMFILE错误。 可以运行以下命令来增加允许同步I / O操作的数量。 123$ ulimit -n 10000复制代码 Process Out of Memory当hexo g时，遇到以下错误： 123FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory复制代码 如下，更改hexo-cli文件的第一行，来增大nodejs堆内存.该bug已在新版本修复。 123#!/usr/bin/env node --max_old_space_size=8192复制代码 Git Deployment Problems RPC failed 12345error: RPC failed; result=22, HTTP code = 403fatal: &apos;username.github.io&apos; does not appear to be a git repository复制代码 确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。 Error: ENOENT: no such file or directory 这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。 解决办法： 检查文章的标签和类别,确保本地和github上是相同的。 合并分支（Commit）。 清除，重构。在站点目录下，命令行（即Git Bash）运行hexo clean和hexo g 手动将站点目录下的public文件夹复制到您的桌面 从你的master分支切换到部署在本地分支。 从桌面复制public文件夹到本地分支。 合并分支到github（Commit）。 切回master分支。 Server Problems123Error: listen EADDRINUSE复制代码 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置： 123$ hexo server -p 5000复制代码 Plugin Installation Problems123npm ERR! node-waf configure build复制代码 这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。 Error with DTrace (Mac OS X)12345&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;复制代码 DTrace安装可能有问题，重装: 123$ npm install hexo --no-optional复制代码 详见 #1326 Iterate Data Model on Jade or SwigHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。 1234&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125;复制代码 Data Not Updated一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次： 123$ hexo clean复制代码 No command is executed那个不能使用除help、init和version以外的命令行（即Git Bash）时, 有可能时站点目录下的package.json文件，缺少hexo ，如下: 1234567&#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;&#125;复制代码 Escape ContentsHexo使用Nunjucks渲染的页面. { { } }或{ % % }将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号： 1​ Hello {{ sensitive }} ​12复制代码 ENOSPC Error (Linux)如果运行命令$ hexo server 返回一个错误: 123Error: watch ENOSPC ...复制代码 可以通过运行$ npm dedupe或者以下命令行（即Git Bash）： 123$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p复制代码 来增加测试时，你可以看见的文件数量。 EMPERM Error (Windows Subsystem for Linux)如果在Windows Subsystem for Linux，运行命令$ hexo server 返回这个错误: 123Error: watch /path/to/hexo/theme/ EMPERM复制代码 因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。 所以需要重新编译，再启动服务器： 1234$ hexo generate$ hexo server -s复制代码 Template render error有时运行命令$ hexo generate 返回一个错误: 1234FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)复制代码 这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件_config.yml中，比如缩进错误： 错误例子： 12345plugins:hexo-generator-feedhexo-generator-sitemap复制代码 常用操作创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
