<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring-task]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F14%2FSpring-task%2F</url>
    <content type="text"><![CDATA[开头从功能上来说，spring-task这个组件主要包括了两个/两种功能: 任务的定时调度/执行，对应xml配置的task:scheduler和task:scheduled-tasks标签。 方法异步执行，对应xml配置的task:executor标签。 task:annotation-driven标签被以上两种功能共有。下面就这两种功能分别进行说明。 定时器用法以XML作为示例，基于注解的也是一样的。 12345&lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;3&quot; /&gt;&lt;bean id=&quot;task&quot; class=&quot;task.Task&quot;/&gt;&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt; &lt;task:scheduled ref=&quot;task&quot; method=&quot;print&quot; cron=&quot;0/5 * * * * ?&quot;/&gt;&lt;/task:scheduled-tasks&gt; 定义了一个定时任务，每隔5秒执行Task的print方法，Task: 12345public class Task &#123; public void print() &#123; System.out.println(&quot;print执行&quot;); &#125;&#125; 关于cron表达式可以参考: 深入浅出Spring task定时任务 解析注册此部分的解析器注册由TaskNamespaceHandler完成: 1234567@Overridepublic void init() &#123; this.registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;executor&quot;, new ExecutorBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;scheduled-tasks&quot;, new ScheduledTasksBeanDefinitionParser()); this.registerBeanDefinitionParser(&quot;scheduler&quot;, new SchedulerBeanDefinitionParser());&#125; schedulerSchedulerBeanDefinitionParser源码: 123456789101112@Overrideprotected String getBeanClassName(Element element) &#123; return &quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;;&#125;@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String poolSize = element.getAttribute(&quot;pool-size&quot;); if (StringUtils.hasText(poolSize)) &#123; builder.addPropertyValue(&quot;poolSize&quot;, poolSize); &#125;&#125; 由于SchedulerBeanDefinitionParser是AbstractSingleBeanDefinitionParser的子类，所以Spring将task:scheduler标签解析为一个BeanDefinition。其beanClass为org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler。 scheduled-tasks其解析的源码较长，在此不再贴出，解析之后形成的BeanDefinition结构如下图: taskScheduler属性即指向task:scheduler标签，如果没有配置，此属性不存在。 Spring将每一个task:scheduled标签解析为一个Task(的子类)，其类图如下: 很明显可以看出，任务的类型是由cron, fixed-delay, fixed-rate, trigger四个属性决定的，fixed-delay和fixed-rate为IntervalTask。 注意一点: 四种任务集合并不是互斥的。比如说一个task:scheduled标签同时配置了cron和trigger属性，那么此标签会导致生成两个beanClass分别为CronTask何TriggerTask的BeanDefinition产生，并分别被放到cronTasksList和triggerTasksList中。 从图中可以看出，task:scheduled的method和ref属性也被包装成了一个BeanDefinition, 其beanClass为org.springframework.scheduling.support.ScheduledMethodRunnable. 调度执行入口便是ContextLifecycleScheduledTaskRegistrar，类图: ContextLifecycleScheduledTaskRegistrar只实现了afterSingletonsInstantiated方法: 1234@Overridepublic void afterSingletonsInstantiated() &#123; scheduleTasks();&#125; ScheduledTaskRegistrar.scheduleTasks: 123456789101112131415161718192021222324252627protected void scheduleTasks() &#123; // shcheduler初始化 if (this.taskScheduler == null) &#123; this.localExecutor = Executors.newSingleThreadScheduledExecutor(); this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor); &#125; if (this.triggerTasks != null) &#123; for (TriggerTask task : this.triggerTasks) &#123; addScheduledTask(scheduleTriggerTask(task)); &#125; &#125; if (this.cronTasks != null) &#123; for (CronTask task : this.cronTasks) &#123; addScheduledTask(scheduleCronTask(task)); &#125; &#125; if (this.fixedRateTasks != null) &#123; for (IntervalTask task : this.fixedRateTasks) &#123; addScheduledTask(scheduleFixedRateTask(task)); &#125; &#125; if (this.fixedDelayTasks != null) &#123; for (IntervalTask task : this.fixedDelayTasks) &#123; addScheduledTask(scheduleFixedDelayTask(task)); &#125; &#125;&#125; scheduler初始化可见，如果没有配置task:scheduler，那么在这里将会进行其初始化工作。 Spring定义了TaskScheduler接口，独立于jdk之外，这样做的目的在于能够同时支持JDK和quartz。对于默认来说，Spring将真正的逻辑全部委托给jdk的Executor。 TaskScheduler类图: ConcurrentTaskExecutor来自另一个继承体系: TaskExecutor，这和spring-task的另一个重要功能，异步执行，这里暂且不表。 任务调度以喜闻乐见的CronTask为例。ScheduledTaskRegistrar.scheduleCronTask: 1234567public ScheduledTask scheduleCronTask(CronTask task) &#123; ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); if (this.taskScheduler != null) &#123; scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()); &#125; return (newTask ? scheduledTask : null);&#125; Trigger可见，Cron也是通过Trigger实现的，在Spring中，Trigger被定义为决定一个任务的下一次执行时间。其类图: 那么问题来了，字符串形式的cron表达式是在何时被解析为Trigger的呢? Cron解析CronTask构造器: 123public CronTask(Runnable runnable, String expression) &#123; this(runnable, new CronTrigger(expression));&#125; CronTrigger构造器: 123public CronTrigger(String expression) &#123; this.sequenceGenerator = new CronSequenceGenerator(expression);&#125; 答案便在CronSequenceGenerator构造器了: 123456789public CronSequenceGenerator(String expression) &#123; this(expression, TimeZone.getDefault());&#125;public CronSequenceGenerator(String expression, TimeZone timeZone) &#123; this.expression = expression; this.timeZone = timeZone; parse(expression);&#125; 具体是如何解析的，不再深入。 ConcurrentTaskScheduler.schedule: 12345@Overridepublic ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger) &#123; ErrorHandler errorHandler = (this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true)); return new ReschedulingRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule();&#125; 调度从上面的源码可以看出，调度是通过ReschedulingRunnable来完成的，其类图: schedule方法: 1234567891011public ScheduledFuture&lt;?&gt; schedule() &#123; synchronized (this.triggerContextMonitor) &#123; this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext); if (this.scheduledExecutionTime == null) &#123; return null; &#125; long initialDelay = this.scheduledExecutionTime.getTime() - System.currentTimeMillis(); this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS); return this; &#125;&#125; 可以看出，这里设置了在下一次执行窗口调用this(ReschedulingRunnable)，从类图可以看出，ReschedulingRunnable本身实现了Runnable接口，其run方法: 12345678910111213@Overridepublic void run() &#123; Date actualExecutionTime = new Date(); super.run(); Date completionTime = new Date(); synchronized (this.triggerContextMonitor) &#123; this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime); if (!this.currentFuture.isCancelled()) &#123; //下次调用 schedule(); &#125; &#125;&#125; 对我们自定义逻辑的调用是通过super.run实现的: 1234@Overridepublic void run() &#123; this.delegate.run();&#125; delegate便是前面提到过的ScheduledMethodRunnable，其run方法: 12345@Overridepublic void run() &#123; ReflectionUtils.makeAccessible(this.method); this.method.invoke(this.target);&#125; 当然这只是针对CronTask的实现，而对于IntervalTask就要简单多了，ScheduledTaskRegistrar.scheduleFixedDelayTask部分源码: 1234567891011121314public ScheduledTask scheduleFixedDelayTask(IntervalTask task) &#123; if (this.taskScheduler != null) &#123; if (task.getInitialDelay() &gt; 0) &#123; Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay()); scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), startTime, task.getInterval()); &#125; else &#123; scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval()); &#125; &#125; return (newTask ? scheduledTask : null);&#125; 总结从上面的说明可以看出，Spring其实将核心逻辑委托给了JDK的Executors.newSingleThreadScheduledExecutor()来实现，那么JDK是如何用一个线程来定时执行多个任务的呢? 异步执行配置必须以注解的方式进行配置，xml: 12&lt;task:executor id=&quot;executor&quot; pool-size=&quot;3&quot;/&gt;&lt;task:annotation-driven executor=&quot;executor&quot;/&gt; 这样在类或方法上加上注解即可: 1234@Async(&quot;executor&quot;)public void print() &#123; System.out.println(&quot;print执行&quot;);&#125; 原理猜测: Spring会为带有@Async的组件生成代理子类实现对原生组件的替换，代理子类将异步执行的方法包装为Task(Runnable)提交到jdk的线程池即可。]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-context]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F12%2FSpring-context%2F</url>
    <content type="text"><![CDATA[开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现: 1234@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; return findParserForElement(element, parserContext).parse(element, parserContext);&#125; findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象: 123456789private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; String localName = parserContext.getDelegate().getLocalName(element); BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element); &#125; return parser;&#125; localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。 annotation-configAnnotationConfigBeanDefinitionParser.parse: 123456789101112131415161718192021@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; //返回null Object source = parserContext.extractSource(element); // Obtain bean definitions for all relevant BeanPostProcessors. Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils. registerAnnotationConfigProcessors(parserContext.getRegistry(), source); // Register component for the surrounding &lt;context:annotation-config&gt; element. CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source); parserContext.pushContainingComponent(compDefinition); // Nest the concrete beans in the surrounding component. for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; parserContext.registerComponent(new BeanComponentDefinition(processorDefinition)); &#125; // Finally register the composite component. // 空实现 parserContext.popAndRegisterContainingComponent(); return null;&#125; BeanPostProcessor注册AnnotationConfigUtils.registerAnnotationConfigProcessors源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//第一个参数其实就是DefaultListableBeanFactory,第二个参数为nullpublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; //将registery强转为DefaultListableBeanFactory类型 DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) &#123; if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123; beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); &#125; if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123; beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); &#125; &#125; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); &#125; return beanDefs;&#125; AnnotationAwareOrderComparator其继承体系如下: 其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考: Spring 4.2新特性-使用@Order调整配置类加载顺序 ContextAnnotationAutowireCandidateResolver此类用以决定一个bean是否可以当作一个依赖的候选者。其类图: ConfigurationClassPostProcessor此类用于处理标注了@Configuration注解的类。类图: AutowiredAnnotationBeanPostProcessor此类便用于对标注了@Autowire等注解的bean或是方法进行注入。 RequiredAnnotationBeanPostProcessor对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。 CommonAnnotationBeanPostProcessor用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码: 12private static final boolean jsr250Present = ClassUtils.isPresent(&quot;javax.annotation.Resource&quot;, AnnotationConfigUtils.class.getClassLoader()); 此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图: PersistenceAnnotationBeanPostProcessor用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码: 123456private static final boolean jpaPresent = ClassUtils.isPresent(&quot;javax.persistence.EntityManagerFactory&quot;, AnnotationConfigUtils.class.getClassLoader()) &amp;&amp; //org.springframework.orm包 ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader()); rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。 EventListenerMethodProcessor提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系: DefaultEventListenerFactory此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图: 逻辑关系整理普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图: 最终形成的数据结构如下图: 不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。 运行ConfigurationClassPostProcessor本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法: 1invokeBeanFactoryPostProcessors(beanFactory); 注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。 postProcessBeanDefinitionRegistry此方法大体由两部分组成。 BeanPostProcessor注册此部分源码: 123456789@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class); iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp); RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class); ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);&#125; ImportAwareBeanPostProcessor是ConfigurationClassPostProcessor的私有内部类。其类图: 此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起: 有一个类负责生成Student bean: 1234567891011121314@Configurationpublic class StudentConfig implements ImportAware &#123; @Bean public Student student() &#123; Student student = new Student(); student.setAge(22); student.setName(&quot;skywalker&quot;); return student; &#125; @Override public void setImportMetadata(AnnotationMetadata importMetadata) &#123; System.out.println(&quot;importaware&quot;); &#125;&#125; 生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean: 123456789101112@Configuration@Import(StudentConfig.class)public class SimpleBeanConfig &#123; @Autowired private StudentConfig studentConfig; @Bean public SimpleBean getSimpleBean() &#123; //bean依赖 SimpleBean simpleBean = new SimpleBean(studentConfig.student()); return simpleBean; &#125;&#125; 启动代码: 123456public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SimpleBeanConfig.class); SimpleBean simpleBean = context.getBean(SimpleBean.class); System.out.println(simpleBean.getStudent().getName());&#125; 所以ImportAware接口的作用就是使被引用的配置类可以获得引用类的相关信息。 EnhancedConfigurationBeanPostProcessor用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。 类解析这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。 bean名字生成策略对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。 ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码: 12345678910111213// Detect any custom bean name generation strategy supplied through the enclosing application contextSingletonBeanRegistry singletonRegistry = null;if (registry instanceof SingletonBeanRegistry) &#123; singletonRegistry = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet &amp;&amp; //org.springframework.context.annotation.internalConfigurationBeanNameGenerator singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123; BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry. getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR); this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125;&#125; 默认是一个AnnotationBeanNameGenerator对象，其类图: 那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: 配置解析、BeanDefinition加载之后，Singleton初始化之前，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。 postProcessBeanFactory此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码: 12345678910111213141516171819202122232425262728public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;(); //寻找@Configuration的BeanDefinition for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; //替换 beanDef.setBeanClass(enhancedClass); &#125; &#125;&#125; ConfigurationClassEnhancer.newEnhancer: 12345678910111213private Enhancer newEnhancer(Class&lt;?&gt; superclass, ClassLoader classLoader) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(superclass); //这里印证了前面EnhancedConfigurationBeanPostProcessor的说明 enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;); enhancer.setUseFactory(false); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)); //关键 enhancer.setCallbackFilter(CALLBACK_FILTER); enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()); return enhancer;&#125; CALLBACK_FILTER是个什么东西呢: 12345678private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);private static final Callback[] CALLBACKS = new Callback[] &#123; new BeanMethodInterceptor(), new BeanFactoryAwareMethodInterceptor(), NoOp.INSTANCE&#125;; 这么做的原因有两个: 提供Scope支持: 我们可以使用@Scope注解来使用注解的方式配置其Scope: 12345678@Bean@Scope(&quot;prototype&quot;)public Student student() &#123; Student student = new Student(); student.setAge(22); student.setName(&quot;skywalker&quot;); return student;&#125; Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。 实现EnhancedConfiguration接口 AutowiredAnnotationBeanPostProcessor类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。 postProcessMergedBeanDefinition入口其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口: AbstractAutowireCapableBeanFactory.doCreateBean(简略): 12345678910111213141516171819protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125;&#125; applyMergedBeanDefinitionPostProcessors: 123456789protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof MergedBeanDefinitionPostProcessor) &#123; MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); &#125; &#125;&#125; 源码12345678@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125;&#125; findAutowiringMetadata: 12345678910111213141516171819private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) &#123; // Fall back to class name as cache key, for backwards compatibility with custom callers. String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // Quick check on the concurrent map first, with minimal locking. InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; synchronized (this.injectionMetadataCache) &#123; metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; if (metadata != null) &#123; metadata.clear(pvs); &#125; metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); &#125; &#125; &#125; return metadata;&#125; injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因: 假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。 对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。 可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。 @Autowire注解的扫描在buildAutowiringMetadata方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123; LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); Class&lt;?&gt; targetClass = clazz; //循环检测父类 do &#123; final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() &#123; @Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException &#123; AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) &#123; //不支持静态变量 if (Modifier.isStatic(field.getModifiers())) &#123; return; &#125; boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); &#125; &#125; &#125;); ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() &#123; @Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException &#123; Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123; return; &#125; AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123; if (Modifier.isStatic(method.getModifiers())) &#123; return; &#125; if (method.getParameterTypes().length == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Autowired annotation should be used on methods with parameters: &quot; + method); &#125; &#125; boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); &#125; &#125; &#125;); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); &#125; while (targetClass != null &amp;&amp; targetClass != Object.class); return new InjectionMetadata(clazz, elements);&#125; 可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，Spring注入注解可以配置在此bean的父类上。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。 变量扫描之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。 ReflectionUtils的实现其实就是访问者模式，其源码: 12345678public static void doWithLocalFields(Class&lt;?&gt; clazz, FieldCallback fc) &#123; for (Field field : getDeclaredFields(clazz)) &#123; try &#123; fc.doWith(field); &#125; catch (IllegalAccessException ex) &#123;&#125; &#125;&#125; determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。 方法扫描bridge方法就是方法扫描的第一行源码: 1Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); 此句代码的作用是判断method是否是bridge方法，如果是，寻找其真正的方法。这里的bridge方法并不是所谓的bridge模式。 有这样的demo代码: 1234567891011121314public class JavaTest &#123; private class MyList extends ArrayList &#123; //注意父类的返回类型是Object @Override public String get(int index) &#123; return &quot;&quot;; &#125; &#125; public static void main(String[] args) &#123; for (Method method : MyList.class.getDeclaredMethods()) &#123; System.out.println(&quot;name: &quot; + method.getName() + &quot;, return: &quot; + method.getReturnType()); &#125; &#125;&#125; 子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出: 12name: get, return: class java.lang.Stringname: get, return: class java.lang.Object 通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method: 1234567891011/** * Returns &#123;@code true&#125; if this method is a bridge * method; returns &#123;@code false&#125; otherwise. * * @return true if and only if this method is a bridge * method as defined by the Java Language Specification. * @since 1.5 */public boolean isBridge() &#123; return (getModifiers() &amp; Modifier.BRIDGE) != 0;&#125; 可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。 可以参考: Java那些不为人知的特殊方法 到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。 PropertyDescriptor用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。 postProcessPropertyValues入口AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。 注入源码: 123456public void processInjection(Object bean) throws BeansException &#123; Class&lt;?&gt; clazz = bean.getClass(); // 查找缓存 InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null); metadata.inject(bean, null, null);&#125; 根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。 Field注入实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。 方法注入实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。 RequiredAnnotationBeanPostProcessor上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。 postProcessMergedBeanDefinition空实现，就是这么任性: 123@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;&#125; postProcessPropertyValues源码: 123456789101112131415161718192021@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; if (!this.validatedBeanNames.contains(beanName)) &#123; if (!shouldSkip(this.beanFactory, beanName)) &#123; List&lt;String&gt; invalidProperties = new ArrayList&lt;String&gt;(); for (PropertyDescriptor pd : pds) &#123; if (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123; invalidProperties.add(pd.getName()); &#125; &#125; if (!invalidProperties.isEmpty()) &#123; throw new BeanInitializationException(buildExceptionMessage (invalidProperties, beanName)); &#125; &#125; this.validatedBeanNames.add(beanName); &#125; return pvs;&#125; 结果缓存validatedBeanNames是一个Set类型，对于已经检查过的bean，将其name加入Set，防止做无用功。 PropertyDescriptor从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢? AbstractAutowireCapableBeanFactory.populateBean相关代码: 123456789101112PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125;&#125; filterPropertyDescriptorsForDependencyCheck单参数方法: 1234567891011protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123; List&lt;PropertyDescriptor&gt; pds = new LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors())); for (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123; PropertyDescriptor pd = it.next(); if (isExcludedFromDependencyCheck(pd)) &#123; it.remove(); &#125; &#125; return pds.toArray(new PropertyDescriptor[pds.size()]);&#125; 可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢? BeanWrapperImpl.getPropertyDescriptors: 1234567891011@Overridepublic PropertyDescriptor[] getPropertyDescriptors() &#123; return getCachedIntrospectionResults().getPropertyDescriptors();&#125;private CachedIntrospectionResults getCachedIntrospectionResults() &#123; Assert.state(getWrappedInstance() != null, &quot;BeanWrapper does not hold a bean instance&quot;); if (this.cachedIntrospectionResults == null) &#123; this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass()); &#125; return this.cachedIntrospectionResults;&#125; 所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。 测试有一个bean如下: 123456789101112131415161718@Component(&quot;simpleBean&quot;)public class SimpleBean &#123; @Autowired(required = false) private Student student; public SimpleBean() &#123;&#125; public SimpleBean(Student student) &#123; this.student = student; &#125; public Student getStudent() &#123; return student; &#125; @Required public void setStudent(Student student) &#123; this.student = student; &#125;&#125; 注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果: CommonAnnotationBeanPostProcessor从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。 postProcessMergedBeanDefinition此方法的执行入口以及调用时机上面已经说过了。其源码: 12345678@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName); if (beanType != null) &#123; InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125;&#125; 父类可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码: 1234567@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; LifecycleMetadata metadata = findLifecycleMetadata(beanType); metadata.checkConfigMembers(beanDefinition); &#125;&#125; findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是遍历所有method寻找初始化和销毁方法标记。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值: 1234public CommonAnnotationBeanPostProcessor() &#123; setInitAnnotationType(PostConstruct.class); setDestroyAnnotationType(PreDestroy.class);&#125; 这两个标签来自于javax.annotation包。那么怎么自定义呢? CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件: 123&lt;bean class=&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot;&gt; &lt;property name=&quot;initAnnotationType&quot; value=&quot;annotation.Init&quot; /&gt;&lt;/bean&gt; Init是一个很简单的自定义注解: 123@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Init &#123;&#125; 在自己的bean中使用此注解: 1234@Initpublic void init() &#123; System.out.println(&quot;Init!&quot;);&#125; 运行Spring便可以看到效果。 另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持。为了达到只有一个实例的目的，需要为前面的配置加上ID。 子类findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。 postProcessPropertyValues源码: 1234567@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) &#123; InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs); metadata.inject(bean, beanName, pvs); return pvs;&#125; 套路很明显了。 postProcessBeforeInitialization实现在父类InitDestroyAnnotationBeanPostProcessor： 123456@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) &#123; LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()); metadata.invokeInitMethods(bean, beanName); return bean;&#125; invokeInitMethods: 12345678910public void invokeInitMethods(Object target, String beanName) throws Throwable &#123; Collection&lt;LifecycleElement&gt; initMethodsToIterate = (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods); if (!initMethodsToIterate.isEmpty()) &#123; for (LifecycleElement element : initMethodsToIterate) &#123; // 反射调用 element.invoke(target); &#125; &#125;&#125; 不过从源码来看应该支持多个init方法。 postProcessBeforeDestruction反射调用销毁方法，没啥说的了。 EventListenerMethodProcessor就一个值得关注的方法: afterSingletonsInstantiated。 入口DefaultListableBeanFactory.preInstantiateSingletons相关源码: 12345678910111213141516171819// Trigger post-initialization callback for all applicable beans...for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125;&#125; 源码略过。 component-scanComponentScanBeanDefinitionParser.parse源码: 12345678910111213141516@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // base-package属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); // 解析占位符 basePackage = parserContext.getReaderContext().getEnvironment() .resolvePlaceholders(basePackage); //分割成数据 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null;&#125; 初始化此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码: 12345678910111213141516171819202122232425protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123; boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123; useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); &#125; // Delegate bean definition registration to scanner class. ClassPathBeanDefinitionScanner scanner = createScanner (parserContext.getReaderContext(), useDefaultFilters); scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader()); scanner.setEnvironment(parserContext.getReaderContext().getEnvironment()); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123; scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); &#125; parseBeanNameGenerator(element, scanner); parseScope(element, scanner); parseTypeFilters(element, scanner, parserContext); return scanner;&#125; 下面开始按顺序分部分说明。 use-default-filterscomponent-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。 扫描器:创建 &amp; 初始化就是createScanner方法和下面那一坨setter方法，没啥好说的。 resource-pattern用以配置扫描器扫描的路径，默认**/*.class。 name-generator可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。 scope-resolver指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图: 默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。 scoped-proxy此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。 exclude-filter/include-filter用法示例: 123&lt;context:component-scan base-package=&quot;base&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;javax.annotation.Resource&quot; /&gt;&lt;/context:component-scan&gt; parseTypeFilters方法负责此部分的解析，只贴部分源码: 1234567if (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123; TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext); scanner.addIncludeFilter(typeFilter);&#125; else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123; TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext); scanner.addExcludeFilter(typeFilter);&#125; annotation-config此属性等同于配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。 扫描入口方法便是ClassPathBeanDefinitionScanner.doScan: 1234567891011121314151617181920212223242526272829protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; // 逐包扫描 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; // 为BeanDefinition设置默认的属性 postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations ((AnnotatedBeanDefinition) candidate); &#125; if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode (scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions;&#125; 逐包扫描/BeanDefinition解析扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图: 对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器: 12345678910111213SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException &#123; InputStream is = new BufferedInputStream(resource.getInputStream()); ClassReader classReader; classReader = new ClassReader(is); AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader); classReader.accept(visitor, ClassReader.SKIP_DEBUG); this.annotationMetadata = visitor; // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor) this.classMetadata = visitor; this.resource = resource;&#125; 解析的关键便在于AnnotationMetadataReadingVisitor，其类图: 核心在于其visitAnnotation方法: 1234567@Overridepublic AnnotationVisitor visitAnnotation(final String desc, boolean visible) &#123; String className = Type.getType(desc).getClassName(); this.annotationSet.add(className); return new AnnotationAttributesReadingVisitor( className, this.attributesMap, this.metaAnnotationMap, this.classLoader);&#125; 返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图: @Scope解析AnnotationScopeMetadataResolver.resolveScopeMetadata: 1234567891011121314151617181920@Overridepublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) &#123; ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) &#123; AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; // 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); if (attributes != null) &#123; // @Scope值 metadata.setScopeName(attributes.getString(&quot;value&quot;)); ScopedProxyMode proxyMode = attributes.getEnum(&quot;proxyMode&quot;); if (proxyMode == null || proxyMode == ScopedProxyMode.DEFAULT) &#123; proxyMode = this.defaultProxyMode; &#125; metadata.setScopedProxyMode(proxyMode); &#125; &#125; return metadata;&#125; proxyMode和xml的scoped-proxy属性是一个概念: 1@Scope(value = &quot;singleton&quot;, proxyMode = ScopedProxyMode.DEFAULT) XML的属性是全局的配置，这个是局部(针对单个bean)的配置，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。 bean名字生成AnnotationBeanNameGenerator.generateBeanName: 123456789101112@Overridepublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123; if (definition instanceof AnnotatedBeanDefinition) &#123; String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition); if (StringUtils.hasText(beanName)) &#123; // Explicit bean name found. return beanName; &#125; &#125; // Fallback: generate a unique default bean name. return buildDefaultBeanName(definition, registry);&#125; 根据注解默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation: 1234567891011121314151617181920212223protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) &#123; AnnotationMetadata amd = annotatedDef.getMetadata(); Set&lt;String&gt; types = amd.getAnnotationTypes(); String beanName = null; // 遍历当前bean拥有的所有类级注解 for (String type : types) &#123; // 获取此注解所有的属性 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type); if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123; Object value = attributes.get(&quot;value&quot;); if (value instanceof String) &#123; String strVal = (String) value; if (StringUtils.hasLength(strVal)) &#123; if (beanName != null &amp;&amp; !strVal.equals(beanName)) &#123; throw new IllegalStateException(); &#125; beanName = strVal; &#125; &#125; &#125; &#125; return beanName;&#125; isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合: 123456789protected boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes) &#123; // org.springframework.stereotype.Component boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) || (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) || annotationType.equals(&quot;javax.annotation.ManagedBean&quot;) || annotationType.equals(&quot;javax.inject.Named&quot;); return (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(&quot;value&quot;));&#125; metaAnnotationTypes用以判断元注解，针对这种情况: 12@Componentpublic @interface Controller &#123;&#125; 可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。 默认策略如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName： 123456protected String buildDefaultBeanName(BeanDefinition definition) &#123; // base.SimpleBean -&gt; SimpleBean String shortClassName = ClassUtils.getShortName(definition.getBeanClassName()); //SimpleBean -&gt; simpleBean return Introspector.decapitalize(shortClassName);&#125; 注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName. 其它注解解析入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个: 123456@Lazy@Primary@DependsOn(&quot;student&quot;)@Role(BeanDefinition.ROLE_APPLICATION)@Description(&quot;This is a simple bean.&quot;)public class SimpleBean &#123;&#125; 这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。 冲突检测Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate: 123456789101112131415protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) &#123; // 没有同名的，直接返回 if (!this.registry.containsBeanDefinition(beanName)) &#123; return true; &#125; BeanDefinition existingDef = this.registry.getBeanDefinition(beanName); BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition(); if (originatingDef != null) &#123; existingDef = originatingDef; &#125; if (isCompatible(beanDefinition, existingDef)) &#123; return false; &#125; throw new ConflictingBeanDefinitionException(&quot;冲突啦!&quot;);&#125; isCompatible用于判断和之前的BeanDefinition是否兼容: 12345678protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) &#123; //// explicitly registered overriding bean return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || //// scanned same file twice newDefinition.getSource().equals(existingDefinition.getSource()) || // scanned equivalent class twice newDefinition.equals(existingDefinition)); &#125; 可以看出，如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。 代理生成入口: ClassPathBeanDefinitionScanner.doScan: 12BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); AnnotationConfigUtils.applyScopedProxyMode: 12345678910static BeanDefinitionHolder applyScopedProxyMode( ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) &#123; ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode(); // 基本都是从这里跑了 if (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123; return definition; &#125; boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS); return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);&#125; 最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点: 这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。 被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。 将被代理者以scopedTarget.原名字注册到容器，返回代理者。 代理者和被代理者同时存在于容器中。 可以看出，这其实是一个偷天换日的过程。 做个实验: 12345678public class Boostrap &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;); SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class)); System.out.println(bean.getClass().getName()); context.close(); &#125;&#125; SimpleBean已开启代理，输出的结果: 1base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61 那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢? DefaultListableBeanFactory.getBean(Class requiredType, Object… args)部分源码: 1234567891011121314String[] beanNames = getBeanNamesForType(requiredType);//不止一个满足条件(代理者和被代理者)if (beanNames.length &gt; 1) &#123; ArrayList&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(); for (String beanName : beanNames) &#123; // here if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123; autowireCandidates.add(beanName); &#125; &#125; if (autowireCandidates.size() &gt; 0) &#123; beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); &#125;&#125; 可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。 BeanDefinition注册你懂的。 Component注册套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。 property-override作用允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo: 定义如下的属性文件(property.properties): 1student.name=dog 格式为: bean名字.属性名字=值。由如下的bean: 1234&lt;bean id=&quot;student&quot; class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;skywalker&quot; /&gt; &lt;property name=&quot;age&quot; value=&quot;30&quot; /&gt;&lt;/bean&gt; 进行如下的配置: 1&lt;context:property-override location=&quot;property.properties&quot; /&gt; 运行如下的代码: 123456public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;); SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class)); System.out.println(bean.getStudent().getName()); context.close();&#125; 打印的便是dog，而不是skywalker。 类图具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下: 解析解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: AbstractPropertyLoadingBeanDefinitionParser.doParse: 12345678910111213141516171819202122232425@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String location = element.getAttribute(&quot;location&quot;); if (StringUtils.hasLength(location)) &#123; String[] locations = StringUtils.commaDelimitedListToStringArray(location); builder.addPropertyValue(&quot;locations&quot;, locations); &#125; String propertiesRef = element.getAttribute(&quot;properties-ref&quot;); if (StringUtils.hasLength(propertiesRef)) &#123; builder.addPropertyReference(&quot;properties&quot;, propertiesRef); &#125; String fileEncoding = element.getAttribute(&quot;file-encoding&quot;); if (StringUtils.hasLength(fileEncoding)) &#123; builder.addPropertyValue(&quot;fileEncoding&quot;, fileEncoding); &#125; String order = element.getAttribute(&quot;order&quot;); if (StringUtils.hasLength(order)) &#123; builder.addPropertyValue(&quot;order&quot;, Integer.valueOf(order)); &#125; builder.addPropertyValue(&quot;ignoreResourceNotFound&quot;, Boolean.valueOf(element.getAttribute(&quot;ignore-resource-not-found&quot;))); builder.addPropertyValue(&quot;localOverride&quot;, Boolean.valueOf(element.getAttribute(&quot;local-override&quot;))); builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);&#125; properties-ref此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例: 123456789&lt;context:property-override properties-ref=&quot;property&quot; /&gt; &lt;bean id=&quot;property&quot; class=&quot;java.util.Properties&quot;&gt; &lt;constructor-arg&gt; &lt;props&gt; &lt;prop key=&quot;student.name&quot;&gt;cat&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 这样便可以看到结果。 order此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。 ignore-resource-not-found如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。 ignore-unresolvable如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。 local-override这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段: 12345678910protected Properties[] localProperties;/** * Set local properties, e.g. via the &quot;props&quot; tag in XML bean definitions. * These can be considered defaults, to be overridden by properties * loaded from files. */public void setProperties(Properties properties) &#123; this.localProperties = new Properties[] &#123;properties&#125;;&#125; 可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下: 1234567891011&lt;context:property-override location=&quot;property.properties&quot; local-override=&quot;false&quot; /&gt;&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyOverrideConfigurer&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;array&gt; &lt;props&gt; &lt;prop key=&quot;student.name&quot;&gt;cat&lt;/prop&gt; &lt;/props&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在) BeanDefinition保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图: 运行入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer): 12345678910111213141516@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; try &#123; // 属性加载 Properties mergedProps = mergeProperties(); // Convert the merged properties, if necessary. convertProperties(mergedProps); // Let the subclass process the properties. processProperties(beanFactory, mergedProps); &#125; catch (IOException ex) &#123; throw new BeanInitializationException(&quot;Could not load properties&quot;, ex); &#125;&#125; 属性加载PropertiesLoaderSupport.mergeProperties: 1234567891011121314151617protected Properties mergeProperties() throws IOException &#123; Properties result = new Properties(); if (this.localOverride) &#123; // Load properties from file upfront, to let local properties override. loadProperties(result); &#125; if (this.localProperties != null) &#123; for (Properties localProp : this.localProperties) &#123; CollectionUtils.mergePropertiesIntoMap(localProp, result); &#125; &#125; if (!this.localOverride) &#123; // Load properties from file afterwards, to let those properties override. loadProperties(result); &#125; return result;&#125; 可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。 属性转换convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。 属性设置就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue: 1234567891011protected void applyPropertyValue( ConfigurableListableBeanFactory factory, String beanName, String property, String value) &#123; BeanDefinition bd = factory.getBeanDefinition(beanName); while (bd.getOriginatingBeanDefinition() != null) &#123; bd = bd.getOriginatingBeanDefinition(); &#125; PropertyValue pv = new PropertyValue(property, value); pv.setOptional(this.ignoreInvalidKeys); bd.getPropertyValues().addPropertyValue(pv);&#125; addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。 property-placeholder这个怎么用已经喜闻乐见了 解析解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。 PropertyPlaceholderBeanDefinitionParser.doParse: 123456789101112131415161718192021@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; super.doParse(element, builder); builder.addPropertyValue(&quot;ignoreUnresolvablePlaceholders&quot;, Boolean.valueOf(element.getAttribute(&quot;ignore-unresolvable&quot;))); String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE); if (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp; !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123; builder.addPropertyValue(&quot;systemPropertiesModeName&quot;, &quot;SYSTEM_PROPERTIES_MODE_&quot; + systemPropertiesModeName); &#125; if (element.hasAttribute(&quot;value-separator&quot;)) &#123; builder.addPropertyValue(&quot;valueSeparator&quot;, element.getAttribute(&quot;value-separator&quot;)); &#125; if (element.hasAttribute(&quot;trim-values&quot;)) &#123; builder.addPropertyValue(&quot;trimValues&quot;, element.getAttribute(&quot;trim-values&quot;)); &#125; if (element.hasAttribute(&quot;null-value&quot;)) &#123; builder.addPropertyValue(&quot;nullValue&quot;, element.getAttribute(&quot;null-value&quot;)); &#125;&#125; system-properties-modeSpring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。 value-separator用于配置默认的值的分隔符: 123&lt;bean id=&quot;student&quot; class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;student.name:skywalker&#125;&quot; /&gt;&lt;/bean&gt; 如果属性文件里没有student.name，那么就是skywalker。默认就是:。 null-value遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。 trim-values是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。 BeanDefinition这次是PropertySourcesPlaceholderConfigurer，其类图: 运行PropertySourcesPlaceholderConfigurer.postProcessBeanFactory： 123456789101112131415161718192021222324252627@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; if (this.propertySources == null) &#123; this.propertySources = new MutablePropertySources(); if (this.environment != null) &#123; this.propertySources.addLast( new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) &#123; @Override public String getProperty(String key) &#123; return this.source.getProperty(key); &#125; &#125; ); &#125; PropertySource&lt;?&gt; localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties()); if (this.localOverride) &#123; this.propertySources.addFirst(localPropertySource); &#125; else &#123; this.propertySources.addLast(localPropertySource); &#125; &#125; processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources)); this.appliedPropertySources = this.propertySources;&#125; 从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样: 不使用property-placeholder标签，以显式的bean定义代替。 处理处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。 load-time-weaver &amp; spring-configured这两个配置是紧密相关的，所以在一起说了。 load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。 可以参考: Spring之LoadTimeWeaver——一个需求引发的思考 Spring LoadTimeWeaver 的那些事儿 javaagent要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例: -javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar 此jar包的META-INF/MANIFEST.MF文件需要配置如下一行: Premain-Class: org.springframework.instrument.InstrumentationSavingAge nt Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码: 123456789101112public class InstrumentationSavingAgent &#123; private static volatile Instrumentation instrumentation; public static void premain(String agentArgs, Instrumentation inst) &#123; instrumentation = inst; &#125; public static Instrumentation getInstrumentation() &#123; return instrumentation; &#125;&#125; 所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。 解析解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。 LoadTimeWeaver此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系: LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName: 123456789@Overrideprotected String getBeanClassName(Element element) &#123; // 如果配置了weaver-class属性，那么使用其值 if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123; return element.getAttribute(WEAVER_CLASS_ATTRIBUTE); &#125; // org.springframework.context.weaving.DefaultContextLoadTimeWeaver return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;&#125; 那么这个BeanDefinition的id/name又是什么呢? LoadTimeWeaverBeanDefinitionParser.resolveId: 12345@Overrideprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext parserContext) &#123; // loadTimeWeaver return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;&#125; DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。 LoadTimeWeaverBeanDefinitionParserLoadTimeWeaverBeanDefinitionParser.doParse: 1234567891011121314@Overrideprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) &#123; builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123; if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME); parserContext.registerBeanComponent( new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME)); &#125; if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123; new SpringConfiguredBeanDefinitionParser().parse(element, parserContext); &#125; &#125;&#125; aspectj-weaving这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。 此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。 是否开启isAspectJWeavingEnabled方法用于判断是否启用: 1234567891011protected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) &#123; if (&quot;on&quot;.equals(value)) &#123; return true; &#125; else if (&quot;off&quot;.equals(value)) &#123; return false; &#125; else &#123; // 寻找aop.xml ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader(); return (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null); &#125;&#125; AspectJWeavingEnabler从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图: SpringConfiguredBeanDefinitionParser如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它: 1registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser()); 其parse方法: 123456789101112131415@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // org.springframework.context.config.internalBeanConfigurerAspect if (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); // org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME); def.setFactoryMethodName(&quot;aspectOf&quot;); def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); def.setSource(parserContext.extractSource(element)); parserContext.registerBeanComponent(new BeanComponentDefinition (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME)); &#125; return null;&#125; 很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图: AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。 下面就去aj文件中看看到底定义了哪些pointcut以及advise。 语法可以参考: Spring 之AOP AspectJ切入点详解 切点(pointcut)inConfigurableBean在AnnotationBeanConfigurerAspect中定义，源码: 1public pointcut inConfigurableBean() : @this(Configurable); @this没找到相关说明，结合@以及this的语义，猜测是匹配带有@Configurable注解(以及作为元注解)的类。 beanConstruction源码: 12public pointcut beanConstruction(Object bean) : initialization(ConfigurableObject+.new(..)) &amp;&amp; this(bean); initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。 preConstructionCondition12private pointcut preConstructionCondition() : leastSpecificSuperTypeConstruction() &amp;&amp; preConstructionConfiguration(); 由两个pointcut与运算而来。 leastSpecificSuperTypeConstruction1public pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..)); preConstructionConfiguration12public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);private pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) &amp;&amp; if (c.preConstruction()); preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。 postConstructionCondition12private pointcut postConstructionCondition() : mostSpecificSubTypeConstruction() &amp;&amp; !preConstructionConfiguration(); mostSpecificSubTypeConstruction: 12public pointcut mostSpecificSubTypeConstruction() : if (thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass()); advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。 advise前置1234before(Object bean) : beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean() &#123; configureBean(bean);&#125; 运行AspectJWeavingEnabler.postProcessBeanFactory: 1234@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);&#125; enableAspectJWeaving: 12345678910111213public static void enableAspectJWeaving(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader) &#123; // 不为空 if (weaverToUse == null) &#123; if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123; weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader); &#125; else &#123; throw new IllegalStateException(&quot;No LoadTimeWeaver available&quot;); &#125; &#125; weaverToUse.addTransformer( new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));&#125; LoadTimeWeaverAwareAspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢? 当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码: 123456// loadTimeWeaverif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));&#125; 很明显，关键在于LoadTimeWeaverAwareProcessor，类图: postProcessBeforeInitialization方法: 123456789101112131415@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) &#123; if (bean instanceof LoadTimeWeaverAware) &#123; LoadTimeWeaver ltw = this.loadTimeWeaver; if (ltw == null) &#123; Assert.state(this.beanFactory != null, &quot;BeanFactory required if no LoadTimeWeaver explicitly specified&quot;); // 去容器找 ltw = this.beanFactory.getBean( ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class); &#125; ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw); &#125; return bean;&#125; 可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。 BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点: BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的: AbstractApplicationContext.refresh: 1234// Invoke factory processors registered as beans in the context.invokeBeanFactoryPostProcessors(beanFactory);// Register bean processors that intercept bean creation.registerBeanPostProcessors(beanFactory); 那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的? AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码: 1234567891011@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; getBeanPostProcessors: 123public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() &#123; return this.beanPostProcessors;&#125; 可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式: 1beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); 直接将实例添加到BeanFactory中，所以可以得出结论: 我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加。 BeanClassLoaderAware入口DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢? AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码: 12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; setBeanClassLoader这个方法很关键，对instrument的获取就是在这里。源码: 1234567891011@Overridepublic void setBeanClassLoader(ClassLoader classLoader) &#123; LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader); if (serverSpecificLoadTimeWeaver != null) &#123; this.loadTimeWeaver = serverSpecificLoadTimeWeaver; &#125; else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123; this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader); &#125; else &#123; this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader); &#125;&#125; 很明显分为三部分。 服务器agentSpring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器: 123&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.&gt; &gt; createServerSpecificLoadTimeWeaver源码: 123456789101112131415protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) &#123; String name = classLoader.getClass().getName(); if (name.startsWith(&quot;weblogic&quot;)) &#123; return new WebLogicLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(&quot;org.glassfish&quot;)) &#123; return new GlassFishLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(&quot;org.apache.catalina&quot;)) &#123; return new TomcatLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(&quot;org.jboss&quot;)) &#123; return new JBossLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(&quot;com.ibm&quot;)) &#123; return new WebSphereLoadTimeWeaver(classLoader); &#125; return null;&#125; 可以看出，对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现。 这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。 Spring agent这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable： 1234567891011public static boolean isInstrumentationAvailable() &#123; return (getInstrumentation() != null);&#125;private static Instrumentation getInstrumentation() &#123; if (AGENT_CLASS_PRESENT) &#123; return InstrumentationAccessor.getInstrumentation(); &#125; else &#123; return null; &#125;&#125; AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。 InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类: 12345private static class InstrumentationAccessor &#123; public static Instrumentation getInstrumentation() &#123; return InstrumentationSavingAgent.getInstrumentation(); &#125;&#125; 这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。 反射在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器: 12345678910111213public ReflectiveLoadTimeWeaver() &#123; this(ClassUtils.getDefaultClassLoader());&#125;public ReflectiveLoadTimeWeaver(ClassLoader classLoader) &#123; Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;); this.classLoader = classLoader; this.addTransformerMethod = ClassUtils.getMethodIfAvailable( this.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class); if (this.addTransformerMethod == null) &#123; throw new IllegalStateException(); &#125;&#125; 总结其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档: Chapter 5. Load-Time Weaving ClassFileTransformer从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。 AspectJClassBypassingClassFileTransformer.transform: 12345678910@Overridepublic byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123; // aspectj自身的类无需检测(织入)，直接跳过 if (className.startsWith(&quot;org.aspectj&quot;) || className.startsWith(&quot;org/aspectj&quot;)) &#123; return classfileBuffer; &#125; return this.delegate.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);&#125; delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图: 根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4. AjAj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。 缓存Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。 WeavingAdaptor初始化初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。 aop.xml解析aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的: 以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例: 12345678910&lt;aspectj&gt; &lt;aspects&gt; &lt;aspect name=&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;/&gt; &lt;aspect name=&quot;org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect&quot;/&gt; &lt;aspect name=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;/&gt; &lt;aspect name=&quot;org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect&quot;/&gt; &lt;aspect name=&quot;org.springframework.cache.aspectj.AnnotationCacheAspect&quot;/&gt; &lt;aspect name=&quot;org.springframework.cache.aspectj.JCacheCacheAspect&quot;/&gt; &lt;/aspects&gt;&lt;/aspectj&gt; 那么解析后的结果: 注册入口方法在ClassLoaderWeavingAdaptor.registerDefinitions: 1234567891011121314private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List&lt;Definition&gt; definitions) &#123; //对应&lt;weaver options=&quot;-verbose&quot;&gt; registerOptions(weaver, loader, definitions); //对应&lt;exclude&gt;标签 registerAspectExclude(weaver, loader, definitions); //对应&lt;include&gt;标签 registerAspectInclude(weaver, loader, definitions); // &lt;aspect&gt; success = registerAspects(weaver, loader, definitions); registerIncludeExclude(weaver, loader, definitions); //对应&lt;dump&gt;标签 registerDump(weaver, loader, definitions); //忽略返回&#125; 总结Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-transaction]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F12%2FSpring-transaction%2F</url>
    <content type="text"><![CDATA[配置以最简单的jdbc事务为例: 1234567891011&lt;!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 解析TxNamespaceHandler.init: 1234567@Overridepublic void init() &#123; registerBeanDefinitionParser(&quot;advice&quot;, new TxAdviceBeanDefinitionParser()); registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser()); registerBeanDefinitionParser(&quot;jta-transaction-manager&quot;, new JtaTransactionManagerBeanDefinitionParser());&#125; 明显解析的入口便在AnnotationDrivenBeanDefinitionParser.parse: 12345678910111213@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; registerTransactionalEventListenerFactory(parserContext); String mode = element.getAttribute(&quot;mode&quot;); if (&quot;aspectj&quot;.equals(mode)) &#123; // mode=&quot;aspectj&quot; registerTransactionAspect(element, parserContext); &#125; else &#123; // mode=&quot;proxy&quot; AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext); &#125; return null;&#125; 下面分部分进行说明。 TransactionalEventListener第一部分用于向Spring容器注册TransactionalEventListener工厂，TransactionalEventListener是Spring4.2引入的新特性，允许我们自定义监听器监听事务的提交或其它动作。 主要组件注册即configureAutoProxyCreator方法，此方法的最终作用便是在Spring容器中加入这样的bean结构: BeanFactoryTransactionAttributeSourceAdvisor-&gt;TransactionInterceptor-&gt;AnnotationTransactionAttributeSource 其中AnnotationTransactionAttributeSource用于解析@Transactional注解的相关属性。 代理类生成与aop模块类似，入口位于configureAutoProxyCreator里注册的bean: InfrastructureAdvisorAutoProxyCreator，其类图: 此类的特殊之处从其名字上可以体现: 只考虑Spring内部使用的基础设施Advisor。 为类创建代理的入口位于AbstractAutoProxyCreator.postProcessAfterInitialization: 12345678910@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean != null) &#123; Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) &#123; return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean;&#125; wrapIfNecessary核心逻辑: 1234567891011protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125;&#125; Advisor寻找getAdvicesAndAdvisorsForBean用于去容器中寻找适合当前bean的Advisor，其最终调用AbstractAdvisorAutoProxyCreator.findEligibleAdvisors: 12345678910protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; //按照@Ordered排序 eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 这个方法在spring-aop中已经详细说明过了，这里再强调一下具体的查找逻辑: 首先去容器找出所有实现了Advisor接口的bean，对应findCandidateAdvisors方法. 逐一判断Advisor是否适用于当前bean，对应findAdvisorsThatCanApply方法，判断逻辑为: 如果Advisor是IntroductionAdvisor，那么判断其ClassFilter是否可以匹配bean的类. 如果Advisor是PointcutAdvisor，那么首先进行ClassFilter匹配，如果匹配失败，那么再获得Advisor的MethodMatcher对象，如果MethodMatcher可以匹配任意方法，那么返回true，否则反射获取给定bean的所有方法逐一进行匹配，只要有一个匹配成功，即返回true. 其它情况，直接返回true. 对于spring事务来说，我们有唯一的Advisor: BeanFactoryTransactionAttributeSourceAdvisor,其类图: 可以看出，BeanFactoryTransactionAttributeSourceAdvisor其实是一个PointcutAdvisor，所以是否可以匹配取决于其Pointcut。此Advisor的pointcut是一个TransactionAttributeSourcePointcut对象，类图: Pointcut的核心在于其ClassFilter和MethodMatcher。 ClassFilter: 位于StaticMethodMatcherPointcut: 1private ClassFilter classFilter = ClassFilter.TRUE; 即: 类检查全部通过。 MethodMatcher: TransactionAttributeSourcePointcut.matches: 123456789@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //如果已经是事务代理，那么不应该再次代理 if (TransactionalProxy.class.isAssignableFrom(targetClass)) &#123; return false; &#125; TransactionAttributeSource tas = getTransactionAttributeSource(); return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);&#125; getTransactionAttribute方法使用了缓存的思想，但其核心逻辑位于AbstractFallbackTransactionAttributeSource.computeTransactionAttribute: 123456789101112131415161718192021222324252627282930313233343536protected TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123; // Don&apos;t allow no-public methods as required. if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123; return null; &#125; // Ignore CGLIB subclasses - introspect the actual user class. Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass); // The method may be on an interface, but we need attributes from the target class. // If the target class is null, the method will be unchanged. Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass); // If we are dealing with method with generic parameters, find the original method. specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod); // First try is the method in the target class. TransactionAttribute txAtt = findTransactionAttribute(specificMethod); if (txAtt != null) &#123; return txAtt; &#125; // Second try is the transaction attribute on the target class. txAtt = findTransactionAttribute(specificMethod.getDeclaringClass()); if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAtt; &#125; if (specificMethod != method) &#123; // Fallback is to look at the original method. txAtt = findTransactionAttribute(method); if (txAtt != null) &#123; return txAtt; &#125; // Last fallback is the class of the original method. txAtt = findTransactionAttribute(method.getDeclaringClass()); if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAtt; &#125; &#125; return null;&#125; 很明显可以看出，首先去方法上查找是否有相应的事务注解(比如@Transactional)，如果没有，那么再去类上查找。 运行以JDK动态代理为例，JdkDynamicAopProxy.invoke简略版源码: 1234567891011121314@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); if (chain.isEmpty()) &#123;. //没有可用的拦截器，直接调用原方法 Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; // We need to create a method invocation... invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. Object retVal = invocation.proceed(); &#125;&#125; 调用链生成即getInterceptorsAndDynamicInterceptionAdvice方法，其原理是: 遍历所有使用的 Advisor，获得其Advice，将Advice转为MethodInterceptor。那么是如何转的呢? 根据Spring的定义，Advice可以是一个MethodInterceptor，也可以是类似于Aspectj的before, after通知。转换由DefaultAdvisorAdapterRegistry.getInterceptors完成: 1234567891011121314151617@Overridepublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor) advice); &#125; for (AdvisorAdapter adapter : this.adapters) &#123; if (adapter.supportsAdvice(advice)) &#123; interceptors.add(adapter.getInterceptor(advisor)); &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; return interceptors.toArray(new MethodInterceptor[interceptors.size()]);&#125; AdvisorAdapter接口用以支持用户自定义的Advice类型，并将自定义的类型转为拦截器。默认adapters含有MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter和ThrowsAdviceAdapter三种类型，用以分别支持MethodBeforeAdvice、AfterReturningAdvice和ThrowsAdvice。 对于我们的BeanFactoryTransactionAttributeSourceAdvisor来说，有且只有一个拦截器: TransactionInterceptor. 调用链调用ReflectiveMethodInvocation.proceed: 12345678910111213141516171819202122@Overridepublic Object proceed() throws Throwable &#123; if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; //拦截器执行完毕，调用原本的方法 return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. return proceed(); &#125; &#125; else &#123; //调用拦截器的invoke方法 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; 可以看出，这其实是一个逐个调用拦截器的invoke方法，最终调用原本方法(被代理方法)的过程。所以，事务添加的核心逻辑(入口)在TransactionInterceptor的invoke方法。 TransactionInterceptorinvoke方法: 12345678910111213@Overridepublic Object invoke(final MethodInvocation invocation) throws Throwable &#123; Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // Adapt to TransactionAspectSupport&apos;s invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123; @Override public Object proceedWithInvocation() throws Throwable &#123; //事务执行完毕后调用链继续向下执行 return invocation.proceed(); &#125; &#125;);&#125; invokeWithinTransaction简略版源码(仅保留PlatformTransactionManager部分): 1234567891011121314151617181920212223242526protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)&#123; // If the transaction attribute is null, the method is non-transactional. final TransactionAttribute txAttr = getTransactionAttributeSource() .getTransactionAttribute(method, targetClass); final PlatformTransactionManager tm = determineTransactionManager(txAttr); //得到方法名 final String joinpointIdentification = methodIdentification(method, targetClass); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; commitTransactionAfterReturning(txInfo); return retVal; &#125;&#125; 事务管理器determineTransactionManager方法用以确定使用的事务管理器: 1234567891011121314151617181920212223protected PlatformTransactionManager determineTransactionManager(TransactionAttribute txAttr) &#123; //如果没有事务属性，那么仅从缓存中查找，找不到返回null if (txAttr == null || this.beanFactory == null) &#123; return getTransactionManager(); &#125; String qualifier = txAttr.getQualifier(); //如果@Transactional注解配置了transactionManager或value属性(用以决定使用哪个事务管理器): //首先查找缓存，找不到再去容器中按名称寻找 if (StringUtils.hasText(qualifier)) &#123; return determineQualifiedTransactionManager(qualifier); &#125; else if (StringUtils.hasText(this.transactionManagerBeanName)) &#123; return determineQualifiedTransactionManager(this.transactionManagerBeanName); &#125; else &#123; //去容器中按类型(Class)查找 PlatformTransactionManager defaultTransactionManager = getTransactionManager(); if (defaultTransactionManager == null) &#123; defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class); this.transactionManagerCache.putIfAbsent( DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager); &#125; return defaultTransactionManager; &#125;&#125; 对于我们使用的DataSourceTransactionManager，类图: afterPropertiesSet方法只是对dataSource进行了检查。 DataSourceDriverManagerDataSource类图: 其中CommonDataSource、Wrapper、DataSource均位于javax.sql包下。 事务开启invocation.proceedWithInvocation()便是我们的逻辑，而createTransactionIfNecessary便是在逻辑执行前开启事务。 TransactionAspectSupport.createTransactionIfNecessary: 12345678910111213141516171819protected TransactionInfo createTransactionIfNecessary( PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) &#123; // If no name specified, apply method identification as transaction name. if (txAttr != null &amp;&amp; txAttr.getName() == null) &#123; txAttr = new DelegatingTransactionAttribute(txAttr) &#123; @Override public String getName() &#123; return joinpointIdentification; &#125; &#125;; &#125; TransactionStatus status = null; if (txAttr != null) &#123; if (tm != null) &#123; status = tm.getTransaction(txAttr); &#125; &#125; return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);&#125; 此部分的核心逻辑在getTransaction和prepareTransactionInfo方法，源码较长，下面依然按部分整理。 是否已存在事务目的在于支撑事务的传播性。 源码位于DataSourceTransactionManager.doGetTransaction，核心逻辑在TransactionSynchronizationManager.doGetResource: 1234567891011121314151617private static Object doGetResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.get(actualKey); // Transparently remove ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value;&#125; actualKey实际上是DataSource对象，resources是一个ThreadLocal对象，其声明源码: 12private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(&quot;Transactional resources&quot;); 从这里可以得出结论: 是否存在事务指的是在当前线程、当前数据源(DataSource)中是否存在处于活动状态的事务。 事务已存在如果检测到已存在事务，那么就要考虑事务的传播特性(行为).此部分源码位于AbstractPlatformTransactionManager.handleExistingTransaction，下面按照不同的传播特性展开。 PROPAGATION_NEVER即当前方法需要在非事务的环境下执行，如果有事务存在，那么抛出异常。相关源码: 1234if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( &quot;Existing transaction found for transaction marked with propagation &apos;never&apos;&quot;);&#125; PROPAGATION_NOT_SUPPORTED与前者的区别在于，如果有事务存在，那么将事务挂起，而不是抛出异常。 123456if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources);&#125; 事务挂起此部分的核心在于suspend方法，最终调用TransactionSynchronizationManager.doUnbindResource: 12345678910111213141516private static Object doUnbindResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; // Transparently suppress a ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; value = null; &#125; return value;&#125; 可以看出，所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程。 同时注意getTransaction方法返回的是一个TransactionStatus对象，被挂起的事务的各种状态都被保存在此对象中。 那么挂起这个操作到底是如何实现(起作用)的呢? DataSourceTransactionManager.doSuspend: 12345678@Overrideprotected Object doSuspend(Object transaction) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; txObject.setConnectionHolder(null); ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.unbindResource(this.dataSource); return conHolder;&#125; 其实玄机就在于将ConnectionHolder设为null这一行，因为一个ConnectionHolder对象就代表了一个数据库连接，将ConnectionHolder设为null就意味着我们下次要使用连接时，将重新从连接池获取，而新的连接的自动提交是为true的。 PROPAGATION_REQUIRES_NEW123456789if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; SuspendedResourcesHolder suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status;&#125; 可以看出，这其实是一个挂起当前活动事务并创建新事务的过程，doBegin方法是事务开启的核心，将在后面进行说明。 PROPAGATION_NESTED其意义: PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. 摘自: 解惑 spring 嵌套事务 核心源码(忽略JTA部分): 1234567891011if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); status.createAndHoldSavepoint(); return status; &#125;&#125; 关键在于如何创建SavePoint, AbstractTransactionStatus.createAndHoldSavepoint: 123public void createAndHoldSavepoint() throws TransactionException &#123; setSavepoint(getSavepointManager().createSavepoint());&#125; DefaultTransactionStatus.getSavepointManager: 12345678@Overrideprotected SavepointManager getSavepointManager() &#123; if (!isTransactionSavepointManager()) &#123; throw new NestedTransactionNotSupportedException( &quot;Transaction object [&quot; + getTransaction() + &quot;] does not support savepoints&quot;); &#125; return (SavepointManager) getTransaction();&#125; 可以看出，SavepointManager实际上从Transaction强转而来，Transaction在Spring都是用Object引用的，那么这到底是个什么东西? debug环境搭建 安装Mysql数据库(或其它支持jdbc)并正确配置数据库连接. 定义两个bean，代表我们的业务逻辑: TransactionBean: 12345678910111213141516@Componentpublic class TransactionBean &#123; private NestedBean nestedBean; public NestedBean getNestedBean() &#123; return nestedBean; &#125; public void setNestedBean(NestedBean nestedBean) &#123; this.nestedBean = nestedBean; &#125; @Transactional(propagation = Propagation.REQUIRED) public void process() &#123; System.out.println(&quot;事务执行&quot;); nestedBean.nest(); &#125;&#125; NestedBean: 1234567@Componentpublic class NestedBean &#123; @Transactional(propagation = Propagation.NESTED) public void nest() &#123; System.out.println(&quot;嵌套事务&quot;); &#125;&#125; 配置文件: 1234&lt;bean id=&quot;nestedBean&quot; class=&quot;base.transaction.NestedBean&quot; /&gt;&lt;bean class=&quot;base.transaction.TransactionBean&quot;&gt; &lt;property name=&quot;nestedBean&quot; ref=&quot;nestedBean&quot; /&gt;&lt;/bean&gt; 入口: 12345public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;); TransactionBean bean = context.getBean(TransactionBean.class); bean.process();&#125; 这样将断点打在合适的位置便可以得到事务对象究竟是什么。 注意: nest方法必须在一个单独的业务bean中，否则对nest的调用并不会导致事务获取的触发。这是由JDK动态代理的实现机制决定的，调用当前类的方法并不会触发代理逻辑(InvocationHandler)。 这一点可以运行demo:test.proxy.JDKProxy看出。 运行debug可以发现，对于DataSourceTransactionManager，事务对象其实是其内部类DataSourceTransactionObject. 事务对象DataSourceTransactionObject的类图如下: Savepoint位于java.sql包下，对于Mysql来说，由Mysql驱动提供实现，类图: 下面来看一下Savepoint到底是如何被创建的。 JdbcTransactionObjectSupport.createSavepoint简略版源码: 12345@Overridepublic Object createSavepoint() throws TransactionException &#123; ConnectionHolder conHolder = getConnectionHolderForSavepoint(); return conHolder.createSavepoint();&#125; ConnectionHolder.createSavepoint: 1234public Savepoint createSavepoint() throws SQLException &#123; this.savepointCounter++; return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);&#125; 我们可以得出这样的结论: Savepoint由java SQL标准定义，具体实现由数据库完成。从mysql的客户端可以直接执行命令savepoint xx可以看出这一点。 其它略。 事务创建如果之前不存在事务，那么就需要创建了，核心逻辑位于DataSourceTransactionManager.doBegin: 123456789101112131415161718192021222324252627282930313233@Overrideprotected void doBegin(Object transaction, TransactionDefinition definition) &#123; //此时，txObject不为null，只是其核心的ConnectHolder属性为null DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; Connection con = null; if (txObject.getConnectionHolder() == null || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123; Connection newCon = this.dataSource.getConnection(); //获得连接，可以看出ConnectionHolder是对Connection的包装 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); &#125; txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); //设置是否只读和隔离级别 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don&apos;t want to do it unnecessarily (for example if we&apos;ve explicitly // configured the connection pool to set it already). if (con.getAutoCommit()) &#123; txObject.setMustRestoreAutoCommit(true); con.setAutoCommit(false); &#125; txObject.getConnectionHolder().setTransactionActive(true); int timeout = determineTimeout(definition); if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123; txObject.getConnectionHolder().setTimeoutInSeconds(timeout); &#125; // Bind the session holder to the thread. if (txObject.isNewConnectionHolder()) &#123; TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder()); &#125;&#125; 到这里便可以得出结论: Spring事务的开启实际上是将数据库的自动提交设为false。 事务提交 &amp; 回滚其实就是对jdbc相应方法的封装，不再展开。 总结事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-aop]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F08%2FSpring-aop%2F</url>
    <content type="text"><![CDATA[开头aop部分的解析器由AopNamespaceHandler注册，其init方法: @Overridepublic void init() { registerBeanDefinitionParser(“config”, new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(“aspectj-autoproxy”, new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(“scoped-proxy”, new ScopedProxyBeanDefinitionDecorator());}aop:config此标签用以配置pointcut, advisor, aspect，实例: ConfigBeanDefinitionParser.parse: @Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) { CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compositeDef); // 是否生成代理类 configureAutoProxyCreator(parserContext, element); List childElts = DomUtils.getChildElements(element); for (Element elt: childElts) { String localName = parserContext.getDelegate().getLocalName(elt); if (POINTCUT.equals(localName)) { parsePointcut(elt, parserContext); } else if (ADVISOR.equals(localName)) { parseAdvisor(elt, parserContext); } else if (ASPECT.equals(localName)) { parseAspect(elt, parserContext); } } parserContext.popAndRegisterContainingComponent(); return null;}解析解析的过程主要分为以下几个部分。 proxy-target-class &amp; expose-proxy对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。 解析的过程无非就是属性的读取，不再详细说明。 aop:pointcutpointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点: BeanDefinition的ID来自于id属性，如果没有，那么自动生成。BeanDefinition的class是AspectJExpressionPointcut。BeanDefinition的scope为prototype。AspectJExpressionPointcut类图: AspectJExpressionPointcut类图 aop:advisor首先是其所有属性的示例: advisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: AOP Alliance (Java/J2EE AOP standards)。Spring官方的说法: aop-schema-advisors。 其相关的包/类就在spring-aop下: aopalliance包 advice-ref是必须的属性，并且这里的advice必须实现org.aopalliance.aop.Advice的子接口。这些子接口指的什么呢，见Spring官方文档: aop-api-advice-types。比如org.aopalliance.intercept.MethodInterceptor。 最常见的用途就是结合事务使用: 解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图: DefaultBeanFactoryPointcutAdvisor类图 另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图: RuntimeBeanReference类图 可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。 aop:aspect配置举例: 解析形成的BeanDefinition结构如下:AspectComponentDefinition beanRefArray RuntimeBeanReference(aop:aspect的ref属性) beanDefArray // 被注册 RootBeanDefinition(aop:declare-parents) beanClass: DeclareParentsAdvisor ConstructorArg implement-interface types-matching default-impl delegate-ref // 被注册 RootBeanDefinition(aop:before,aop:after…) beanClass: AspectJPointcutAdvisor ConstructorArg RootBeanDefinition beanClass: 由子标签决定 ConstructorArg RootBeanDefinition beanClass: MethodLocatingFactoryBean properties targetBeanName: aspectName methodName: method属性 RootBeanDefinition beanClass: SimpleBeanFactoryAwareAspectInstanceFactory properties aspectBeanName: aspectName //还有pointcut定义和引用…结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。aop:declare-parents对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口:此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图:DeclareParentsAdvisor类图其它此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图:AspectJPointcutAdvisor类图正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码:private Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) { String elementName = parserContext.getDelegate().getLocalName(adviceElement); if (BEFORE.equals(elementName)) { return AspectJMethodBeforeAdvice.class; } else if (AFTER.equals(elementName)) { return AspectJAfterAdvice.class; } else if (AFTER_RETURNING_ELEMENT.equals(elementName)) { return AspectJAfterReturningAdvice.class; } else if (AFTER_THROWING_ELEMENT.equals(elementName)) { return AspectJAfterThrowingAdvice.class; } else if (AROUND.equals(elementName)) { return AspectJAroundAdvice.class; }}而此BeanDefintion的构造参数又由以下三个部分组成:MethodLocatingFactoryBean第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图:MethodLocatingFactoryBean类图这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法:@Overridepublic void setBeanFactory(BeanFactory beanFactory) { Class&lt;?&gt; beanClass = beanFactory.getType(this.targetBeanName); this.method = BeanUtils.resolveSignature(this.methodName, beanClass);}SimpleBeanFactoryAwareAspectInstanceFactory其类图:SimpleBeanFactoryAwareAspectInstanceFactory类图此类用于在BeanFactory中定位aspect bean，这个bean指的是谁?就是它!查找很简单:@Overridepublic Object getAspectInstance() { return this.beanFactory.getBean(this.aspectBeanName);}总结从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。代理子类生成关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图:AspectJAwareAdvisorAutoProxyCreator类图那么子类生成的入口在哪里呢?入口从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。postProcessBeforeInstantiation调用时机先来回顾一下此方法在Bean创建的过程中的调用时机。AbstractAutowireCapableBeanFactory.createBean部分源码://// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.Object bean = resolveBeforeInstantiation(beanName, mbdToUse);if (bean != null) { return bean;}Object beanInstance = doCreateBean(beanName, mbdToUse, args);可以看出，调用发生在Bean实例的创建之前。源码AbstractAutoProxyCreator.postProcessBeforeInstantiation:@Overridepublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) { Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.contains(beanName)) { if (this.advisedBeans.containsKey(cacheKey)) { return null; } if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; } } if (beanName != null) { TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) { this.targetSourcedBeans.add(beanName); Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } } return null;}下面分部分对其进行说明。应该代理 ?Spring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。不应该代理的类分为两种情况:用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。基础类检测AbstractAutoProxyCreator.isInfrastructureClass:protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) { boolean retVal = Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass); return retVal;}可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。跳过类检测即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写:@Overrideprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) { List candidateAdvisors = findCandidateAdvisors(); for (Advisor advisor : candidateAdvisors) { if (advisor instanceof AspectJPointcutAdvisor) { if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) { return true; } } } return super.shouldSkip(beanClass, beanName);}那么此方法跳过的是谁呢？其实就是我们通过aop:aspect标签配置的切面，即: 里的aopAdvice。从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。所以可以得出结论: Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象。AOP逻辑AOP逻辑图那么Spring又是如何找到适用于当前bean的Advisor的呢?Advisor寻找关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans:public List findAdvisorBeans() { String[] advisorNames = null; synchronized (this) { // 结果缓存 advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) { // 去容器中寻找 advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; } } if (advisorNames.length == 0) { return new LinkedList(); } List advisors = new LinkedList(); for (String name : advisorNames) { if (isEligibleBean(name)) { if (!this.beanFactory.isCurrentlyInCreation(name)) { advisors.add(this.beanFactory.getBean(name, Advisor.class)); } } } return advisors;}可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。适用性检测指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法:protected boolean isEligibleAdvisorBean(String beanName) { return true;}而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对容器中所有的Advisor的Advice进行跳过。检测结果缓存因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。TargetSource从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图:TargetSource类图关于此接口在此不展开叙述。postProcessAfterInitializationAbstractAutoProxyCreator.postProcessAfterInitialization:@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) { if (bean != null) { Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) { return wrapIfNecessary(bean, beanName, cacheKey); } } return bean;}关键便在于wrapIfNecessary方法:protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) { //自定义TargetSource，已经进行过代理子类生成 if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) { return bean; } if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) { return bean; } if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) { this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; } // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) { this.advisedBeans.put(cacheKey, Boolean.TRUE); // 创建 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; } this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;}可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。Advisor寻找即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是AbstractAdvisorAutoProxyCreator.findEligibleAdvisors:protected List findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) { List candidateAdvisors = findCandidateAdvisors(); List eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) { eligibleAdvisors = sortAdvisors(eligibleAdvisors); } return eligibleAdvisors;}findCandidateAdvisors前面已经说过了。适用性判断findAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply:public static List findAdvisorsThatCanApply(List candidateAdvisors, Class&lt;?&gt; clazz) { if (candidateAdvisors.isEmpty()) { return candidateAdvisors; } List eligibleAdvisors = new LinkedList(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) { eligibleAdvisors.add(candidate); } } boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) { if (candidate instanceof IntroductionAdvisor) { // already processed continue; } if (canApply(candidate, clazz, hasIntroductions)) { eligibleAdvisors.add(candidate); } } return eligibleAdvisors;}关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。这种分开处理导致了IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面。canApply(candidate, clazz)其实等价于canApply(candidate, clazz, false):public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) { if (advisor instanceof IntroductionAdvisor) { return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); } else if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); } else { // It doesn’t have a pointcut so we assume it applies. return true; }}很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。引入引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。其它AopUtils.canApply:public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) { //是否Pointcut可以匹配当前类 if (!pc.getClassFilter().matches(targetClass)) { return false; } MethodMatcher methodMatcher = pc.getMethodMatcher(); //是否Pointcut可以匹配所有方法 if (methodMatcher == MethodMatcher.TRUE) { // No need to iterate the methods if we’re matching any method anyway… return true; } IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) { introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; } Set]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-core]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F04%2FSpring%20IOC%20%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基本本部分从最基本的Spring开始。配置文件: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean class=&quot;base.SimpleBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 启动代码: 123456public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;); SimpleBean bean = context.getBean(SimpleBean.class); bean.send(); context.close();&#125; SimpleBean: 12345public class SimpleBean &#123; public void send() &#123; System.out.println(&quot;I am send method from SimpleBean!&quot;); &#125;&#125; ClassPathXmlApplicationContext整个继承体系如下: ResourceLoader代表了加载资源的一种方式，正是策略模式的实现。 构造器源码: 123456789public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) &#123; //null super(parent); setConfigLocations(configLocations); //默认true if (refresh) &#123; refresh(); &#125;&#125; 构造器首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext: 1234567public AbstractApplicationContext(ApplicationContext parent) &#123; this(); setParent(parent);&#125;public AbstractApplicationContext() &#123; this.resourcePatternResolver = getResourcePatternResolver();&#125; getResourcePatternResolver: 123protected ResourcePatternResolver getResourcePatternResolver() &#123; return new PathMatchingResourcePatternResolver(this);&#125; PathMatchingResourcePatternResolver支持Ant风格的路径解析。 设置配置文件路径即AbstractRefreshableConfigApplicationContext.setConfigLocations: 1234567891011public void setConfigLocations(String... locations) &#123; if (locations != null) &#123; Assert.noNullElements(locations, &quot;Config locations must not be null&quot;); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) &#123; this.configLocations[i] = resolvePath(locations[i]).trim(); &#125; &#125; else &#123; this.configLocations = null; &#125;&#125; resolvePath: 123protected String resolvePath(String path) &#123; return getEnvironment().resolveRequiredPlaceholders(path);&#125; 此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);那么classpath:就是需要被解析的。 getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment: 123protected ConfigurableEnvironment createEnvironment() &#123; return new StandardEnvironment();&#125; Environment接口继承体系: Environmen接口代表了当前应用所处的环境。从此接口的方法可以看出，其主要和profile、Property相关。 ProfileSpring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。Spring容器管理的所有bean都是和一个profile绑定在一起的。使用了Profile的配置文件示例: 123456789&lt;beans profile=&quot;develop&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-develop.properties&quot;/&gt; &lt;/beans&gt; &lt;beans profile=&quot;production&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-production.properties&quot;/&gt; &lt;/beans&gt; &lt;beans profile=&quot;test&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-test.properties&quot;/&gt; &lt;/beans&gt; 在启动代码中可以用如下代码设置活跃(当前使用的)Profile: 1context.getEnvironment().setActiveProfiles(&quot;dev&quot;); 当然使用的方式还有很多(比如注解)，参考: spring3.1 profile 配置不同的环境 Spring Profiles example Property这里的Property指的是程序运行时的一些参数，引用注释: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on. Environment构造器1234private final MutablePropertySources propertySources = new MutablePropertySources(this.logger);public AbstractEnvironment() &#123; customizePropertySources(this.propertySources);&#125; PropertySources接口继承体系: 此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。 StandardEnvironment.customizePropertySources: 1234567891011/** System environment property source name: &#123;@value&#125; */public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = &quot;systemEnvironment&quot;;/** JVM system properties property source name: &#123;@value&#125; */public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = &quot;systemProperties&quot;;@Overrideprotected void customizePropertySources(MutablePropertySources propertySources) &#123; propertySources.addLast(new MapPropertySource (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties())); propertySources.addLast(new SystemEnvironmentPropertySource (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));&#125; PropertySource接口PropertySource接口代表了键值对的Property来源。继承体系： AbstractEnvironment.getSystemProperties: 123456789101112131415161718192021222324@Overridepublic Map&lt;String, Object&gt; getSystemProperties() &#123; try &#123; return (Map) System.getProperties(); &#125; catch (AccessControlException ex) &#123; return (Map) new ReadOnlySystemAttributesMap() &#123; @Override protected String getSystemAttribute(String attributeName) &#123; try &#123; return System.getProperty(attributeName); &#125; catch (AccessControlException ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(format(&quot;Caught AccessControlException when accessing system &quot; + &quot;property [%s]; its value will be returned [null]. Reason: %s&quot;, attributeName, ex.getMessage())); &#125; return null; &#125; &#125; &#125;; &#125;&#125; 这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。 getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。 路径Placeholder处理AbstractEnvironment.resolveRequiredPlaceholders: 12345@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; //text即配置文件路径，比如classpath:config.xml return this.propertyResolver.resolveRequiredPlaceholders(text);&#125; propertyResolver是一个PropertySourcesPropertyResolver对象: 12private final ConfigurablePropertyResolver propertyResolver = new PropertySourcesPropertyResolver(this.propertySources); PropertyResolver接口PropertyResolver继承体系(排除Environment分支): 此接口正是用来解析PropertyResource。 解析AbstractPropertyResolver.resolveRequiredPlaceholders: 123456789101112@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; if (this.strictHelper == null) &#123; this.strictHelper = createPlaceholderHelper(false); &#125; return doResolvePlaceholders(text, this.strictHelper);&#125;private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) &#123; //三个参数分别是$&#123;, &#125;, : return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, ignoreUnresolvablePlaceholders);&#125; doResolvePlaceholders： 123456789private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) &#123; //PlaceholderResolver接口依然是策略模式的体现 return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() &#123; @Override public String resolvePlaceholder(String placeholderName) &#123; return getPropertyAsRawString(placeholderName); &#125; &#125;);&#125; 其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写: 123System.setProperty(&quot;spring&quot;, &quot;classpath&quot;);ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;$&#123;spring&#125;:config.xml&quot;);SimpleBean bean = context.getBean(SimpleBean.class); 这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty: 12345678910111213@Overrideprotected String getPropertyAsRawString(String key) &#123; return getProperty(key, String.class, false);&#125;protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); return value; &#125; &#125; return null;&#125; 很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。 注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。 refreshSpring bean解析就在此方法，所以单独提出来。 AbstractApplicationContext.refresh: 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&apos;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; prepareRefresh1234567891011121314protected void prepareRefresh() &#123; this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); // Initialize any placeholder property sources in the context environment //空实现 initPropertySources(); // Validate that all properties marked as required are resolvable // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125; 属性校验AbstractEnvironment.validateRequiredProperties: 1234@Overridepublic void validateRequiredProperties() throws MissingRequiredPropertiesException &#123; this.propertyResolver.validateRequiredProperties();&#125; AbstractPropertyResolver.validateRequiredProperties: 123456789101112@Overridepublic void validateRequiredProperties() &#123; MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException(); for (String key : this.requiredProperties) &#123; if (this.getProperty(key) == null) &#123; ex.addMissingRequiredProperty(key); &#125; &#125; if (!ex.getMissingRequiredProperties().isEmpty()) &#123; throw ex; &#125;&#125; requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。 BeanFactory创建由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory: 12345678910111213141516@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; //如果已经存在，那么销毁之前的 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; //创建了一个DefaultListableBeanFactory对象 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125;&#125; BeanFactory接口此接口实际上就是Bean容器，其继承体系: BeanFactory定制AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现: 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; //默认false，不允许覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; //默认false，不允许循环引用 beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; Bean加载AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了: 123456789101112131415@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. //默认空实现 initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; EntityResolver此处只说明用到的部分继承体系: EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。 BeanDefinitionReader继承体系: 路径解析(Ant)1234567891011protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); //here if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; AbstractBeanDefinitionReader.loadBeanDefinitions: 123456789@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123; Assert.notNull(locations, &quot;Location array must not be null&quot;); int counter = 0; for (String location : locations) &#123; counter += loadBeanDefinitions(location); &#125; return counter;&#125; 之后调用: 12345678910111213141516171819202122232425262728293031//第二个参数为空public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) &#123; ResourceLoader resourceLoader = getResourceLoader(); //参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口 if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; return loadCount; &#125;&#125; getResource的实现在AbstractApplicationContext： 12345@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; //构造器中初始化，PathMatchingResourcePatternResolver对象 return this.resourcePatternResolver.getResources(locationPattern);&#125; PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。 123456789101112131415161718192021222324252627282930@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); //classpath: if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible) //matcher是一个AntPathMatcher对象 if (getPathMatcher().isPattern(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // Only look for a pattern after a prefix here // (to not get fooled by a pattern symbol in a strange prefix). int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1; if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; isPattern: 1234@Overridepublic boolean isPattern(String path) &#123; return (path.indexOf(&apos;*&apos;) != -1 || path.indexOf(&apos;?&apos;) != -1);&#125; 可以看出配置文件路径是支持ant风格的，也就是可以这么写: 1new ClassPathXmlApplicationContext(&quot;con*.xml&quot;); 具体怎么解析ant风格的就不写了。 配置文件加载入口方法在AbstractBeanDefinitionReader的217行: 1234//加载Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);//解析int loadCount = loadBeanDefinitions(resources); 最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法: 1234@Overridepublic int loadBeanDefinitions(Resource resource) &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125; Resource是代表一种资源的接口，其类图: EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。 之后关键的源码只有两行: 12345public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); InputSource inputSource = new InputSource(inputStream); return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125; InputSource是org.xml.sax的类。 doLoadBeanDefinitions： 1234protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource);&#125; doLoadDocument: 1234protected Document doLoadDocument(InputSource inputSource, Resource resource) &#123; return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。 校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。 NamespaceAware默认false，因为默认配置了校验为true。 DefaultDocumentLoader.loadDocument: 12345678@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) &#123; //这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; createDocumentBuilderFactory比较有意思: 12345678910111213141516protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(namespaceAware); if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123; //此方法设为true仅对dtd有效，xsd(schema)无效 factory.setValidating(true); if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123; // Enforce namespace aware for XSD... //开启xsd(schema)支持 factory.setNamespaceAware(true); //这个也是Java支持Schema的套路，可以问度娘 factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); &#125; &#125; return factory;&#125; Bean解析XmlBeanDefinitionReader.registerBeanDefinitions: 123456public int registerBeanDefinitions(Document doc, Resource resource) &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; createBeanDefinitionDocumentReader: 12345protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanDefinitionDocumentReader.class.cast //反射 (BeanUtils.instantiateClass(this.documentReaderClass));&#125; documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。 注意cast方法，代替了强转。 createReaderContext： 1234public XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());&#125; problemReporter是一个FailFastProblemReporter对象。 eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。 sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。 getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。 XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。 DefaultBeanDefinitionDocumentReader.registerBeanDefinitions: 123456@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; doRegisterBeanDefinitions: 12345678910111213141516171819202122protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); //默认的命名空间即 //http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) &#123; //检查profile属性 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; //profile属性可以以,分割 String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的: 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean class=&quot;base.SimpleBean&quot;&gt;&lt;/bean&gt; &lt;beans&gt; &lt;bean class=&quot;java.lang.Object&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;&lt;/beans&gt; xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样: 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&gt;&lt;/beans&gt; xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。 注意一下profile的检查, AbstractEnvironment.acceptsProfiles: 1234567891011121314@Overridepublic boolean acceptsProfiles(String... profiles) &#123; Assert.notEmpty(profiles, &quot;Must specify at least one profile&quot;); for (String profile : profiles) &#123; if (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(0) == &apos;!&apos;) &#123; if (!isProfileActive(profile.substring(1))) &#123; return true; &#125; &#125; else if (isProfileActive(profile)) &#123; return true; &#125; &#125; return false;&#125; 原理很简单，注意从源码可以看出，profile属性支持!取反。 preProcessXml方法是个空实现，供子类去覆盖，目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会, 想的真周到。 DefaultBeanDefinitionDocumentReader.parseBeanDefinitions： 123456789101112131415161718protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 可见，对于非默认命名空间的元素交由delegate处理。 默认命名空间解析即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement: 12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //&quot;import&quot; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; import写法示例: 12&lt;import resource=&quot;CTIContext.xml&quot; /&gt;&lt;import resource=&quot;customerContext.xml&quot; /&gt; importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。 alias加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义: 1&lt;alias name=&quot;componentA-dataSource&quot; alias=&quot;componentB-dataSource&quot;/&gt; processAliasRegistration核心源码: 123456protected void processAliasRegistration(Element ele) &#123; String name = ele.getAttribute(NAME_ATTRIBUTE); String alias = ele.getAttribute(ALIAS_ATTRIBUTE); getReaderContext().getRegistry().registerAlias(name, alias); getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));&#125; 从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry: 12345678910111213141516171819202122232425@Overridepublic void registerAlias(String name, String alias) &#123; Assert.hasText(name, &quot;&apos;name&apos; must not be empty&quot;); Assert.hasText(alias, &quot;&apos;alias&apos; must not be empty&quot;); //名字和别名一样 if (alias.equals(name)) &#123; //ConcurrentHashMap this.aliasMap.remove(alias); &#125; else &#123; String registeredName = this.aliasMap.get(alias); if (registeredName != null) &#123; if (registeredName.equals(name)) &#123; // An existing alias - no need to re-register return; &#125; if (!allowAliasOverriding()) &#123; throw new IllegalStateException (&quot;Cannot register alias &apos;&quot; + alias + &quot;&apos; for name &apos;&quot; + name + &quot;&apos;: It is already registered for name &apos;&quot; + registeredName + &quot;&apos;.&quot;); &#125; &#125; checkForAliasCircle(name, alias); this.aliasMap.put(alias, name); &#125;&#125; 所以别名关系的保存使用Map完成，key为别名，value为本来的名字。 beanbean节点是Spring最最常见的节点了。 DefaultBeanDefinitionDocumentReader.processBeanDefinition: 1234567891011121314151617protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition (bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; id &amp; name处理最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。 首先获取到id和name属性，name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做。 1234567891011121314151617181920String id = ele.getAttribute(ID_ATTRIBUTE);String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();if (StringUtils.hasLength(nameAttr)) &#123; //按,分隔 String[] nameArr = StringUtils.tokenizeToStringArray (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr));&#125;String beanName = id;if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; //name的第一个值作为id beanName = aliases.remove(0);&#125;//默认nullif (containingBean == null) &#123; //校验id是否已重复，如果重复直接抛异常 //校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set checkNameUniqueness(beanName, aliases, ele);&#125; beanName生成如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement: 123beanName = this.readerContext.generateBeanName(beanDefinition);String beanClassName = beanDefinition.getBeanClassName();aliases.add(beanClassName); 可见，Spring同时会把类名作为其别名。 最终调用的是BeanDefinitionReaderUtils.generateBeanName: 12345678910111213141516171819202122232425262728public static String generateBeanName( BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) &#123; String generatedBeanName = definition.getBeanClassName(); if (generatedBeanName == null) &#123; if (definition.getParentName() != null) &#123; generatedBeanName = definition.getParentName() + &quot;$child&quot;; //工厂方法产生的bean &#125; else if (definition.getFactoryBeanName() != null) &#123; generatedBeanName = definition.getFactoryBeanName() + &quot;$created&quot;; &#125; &#125; String id = generatedBeanName; if (isInnerBean) &#123; // Inner bean: generate identity hashcode suffix. id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); &#125; else &#123; // Top-level bean: use plain class name. // Increase counter until the id is unique. int counter = -1; //用类名#自增的数字命名 while (counter == -1 || registry.containsBeanDefinition(id)) &#123; counter++; id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter; &#125; &#125; return id;&#125; bean解析还是分部分说明(parseBeanDefinitionElement)。 首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。 123456789String className = null;if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;String parent = null;if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE);&#125;AbstractBeanDefinition bd = createBeanDefinition(className, parent); BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition: 1234567891011121314public static AbstractBeanDefinition createBeanDefinition( String parentName, String className, ClassLoader classLoader) &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; 之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中: 1parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 之后解析bean的decription子元素: 123&lt;bean id=&quot;b&quot; name=&quot;one, two&quot; class=&quot;base.SimpleBean&quot;&gt; &lt;description&gt;SimpleBean&lt;/description&gt;&lt;/bean&gt; 就仅仅是个描述。 然后是meta子元素的解析，meta元素在xml配置文件里是这样的: 123&lt;bean id=&quot;b&quot; name=&quot;one, two&quot; class=&quot;base.SimpleBean&quot;&gt; &lt;meta key=&quot;name&quot; value=&quot;skywalker&quot;/&gt;&lt;/bean&gt; 注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码: 12345678910111213141516public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) &#123; NodeList nl = ele.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123; Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); //就是一个key, value的载体，无他 BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); //sourceExtractor默认是NullSourceExtractor，返回的是空 attribute.setSource(extractSource(metaElement)); attributeAccessor.addMetadataAttribute(attribute); &#125; &#125;&#125; AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。 lookup-method解析： 此标签的作用在于当一个bean的某个方法被设置为lookup-method后，每次调用此方法时，都会返回一个新的指定bean的对象。用法示例: 12345&lt;bean id=&quot;apple&quot; class=&quot;cn.com.willchen.test.di.Apple&quot; scope=&quot;prototype&quot;/&gt;&lt;!--水果盘--&gt;&lt;bean id=&quot;fruitPlate&quot; class=&quot;cn.com.willchen.test.di.FruitPlate&quot;&gt; &lt;lookup-method name=&quot;getFruit&quot; bean=&quot;apple&quot;/&gt;&lt;/bean&gt; 数据保存在Set中，对应的类是MethodOverrides。可以参考: Spring - lookup-method方式实现依赖注入 replace-mothod解析: 此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。 配置文件示例: 123456&lt;bean name=&quot;replacer&quot; class=&quot;springroad.deomo.chap4.MethodReplace&quot; /&gt; &lt;bean name=&quot;testBean&quot; class=&quot;springroad.deomo.chap4.LookupMethodBean&quot;&gt; &lt;replaced-method name=&quot;test&quot; replacer=&quot;replacer&quot;&gt; &lt;arg-type match=&quot;String&quot; /&gt; &lt;/replaced-method&gt; &lt;/bean&gt; arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: SPRING.NET 1.3.2 学习20–方法注入之替换方法注入 解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList专门用于保存arg-type。 构造参数(constructor-arg)解析: 作用一目了然，使用示例: 12345&lt;bean class=&quot;base.SimpleBean&quot;&gt; &lt;constructor-arg&gt; &lt;value type=&quot;java.lang.String&quot;&gt;Cat&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map的形式保存，反之，以List的形式保存。 property解析: 非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例: 123&lt;bean class=&quot;base.SimpleBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;skywalker&quot; /&gt;&lt;/bean&gt; value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。 qualifier解析: 配置示例: 1234567891011&lt;bean class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;skywalker&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/property&gt; &lt;qualifier type=&quot;org.springframework.beans.factory.annotation.Qualifier&quot; value=&quot;student&quot; /&gt;&lt;/bean&gt; &lt;bean class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;seaswalker&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt; &lt;qualifier value=&quot;student_2&quot;&gt;&lt;/qualifier&gt;&lt;/bean&gt;&lt;bean class=&quot;base.SimpleBean&quot; /&gt; SimpleBean部分源码: 123@Autowired@Qualifier(&quot;student&quot;)private Student student; 此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如: 123&lt;qualifier type=&quot;org.springframework.beans.factory.annotation.Qualifier&quot; value=&quot;student&quot;&gt; &lt;attribute key=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;/qualifier&gt; 貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。 Bean装饰这部分是针对其它schema的属性以及子节点，比如: 123&lt;bean class=&quot;base.Student&quot; primary=&quot;true&quot;&gt; &lt;context:property-override /&gt;&lt;/bean&gt; 没见过这种用法，留个坑。 Bean注册BeanDefinitionReaderUtils.registerBeanDefinition: 12345678910111213public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &#123; // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事: 12345@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName);&#125; 一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。 ComponentRegistered事件触发: 默认是个空实现，前面说过了。 BeanDefiniton数据结构BeanDefiniton数据结构如下图: beansbeans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。 其它命名空间解析入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空): 12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。 其resolve方法: 1234567891011121314151617@Overridepublic NamespaceHandler resolve(String namespaceUri) &#123; Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125;&#125; 容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回。 NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例: 12345http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandlerhttp\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler NamespaceHandler继承体系 initresolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。此接口用以解析顶层(beans下)的非默认命名空间元素，比如。 所以这样逻辑就很容易理解了: 每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程。 此部分较为重要，所以重新开始大纲。 BeanFactory数据结构BeanDefinition在BeanFactory中的主要数据结构如下图: prepareBeanFactory此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面: BeanExpressionResolver此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法: 1Object evaluate(String value, BeanExpressionContext evalContext) prepareBeanFactory将一个此对象放入BeanFactory: 1beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图: 这便是Spring3.0开始出现的Spel表达式的解释器。 PropertyEditorRegistrar此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法: 1registerCustomEditors(PropertyEditorRegistry registry) 实现也只有一个: ResourceEditorRegistrar。 在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。 prepareBeanFactory: 1beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。 我们有两种方式可以添加自定义PropertyEditor: 通过context.getBeanFactory().registerCustomEditor 通过Spring配置文件: 1234567&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;property name=&quot;customEditors&quot;&gt; &lt;map&gt; &lt;entry key=&quot;base.Cat&quot; value=&quot;base.CatEditor&quot; /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 参考: 深入理解JavaBean(2)：属性编辑器PropertyEditor 环境注入在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory: 1beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法: 1234567891011private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; //.... &#125;&#125; 依赖解析忽略此部分设置哪些接口在进行依赖注入的时候应该被忽略: 12345beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);beanFactory.ignoreDependencyInterface(MessageSourceAware.class);beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);beanFactory.ignoreDependencyInterface(EnvironmentAware.class); bean伪装有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下: 1234beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);beanFactory.registerResolvableDependency(ResourceLoader.class, this);beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);beanFactory.registerResolvableDependency(ApplicationContext.class, this); 伪装关系保存在一个Map]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-core]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F06%2F04%2FSpring-core%2F</url>
    <content type="text"><![CDATA[基本本部分从最基本的Spring开始。配置文件: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean class=&quot;base.SimpleBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 启动代码: 123456public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;); SimpleBean bean = context.getBean(SimpleBean.class); bean.send(); context.close();&#125; SimpleBean: 12345public class SimpleBean &#123; public void send() &#123; System.out.println(&quot;I am send method from SimpleBean!&quot;); &#125;&#125; ClassPathXmlApplicationContext整个继承体系如下: ResourceLoader代表了加载资源的一种方式，正是策略模式的实现。 构造器源码: 123456789public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) &#123; //null super(parent); setConfigLocations(configLocations); //默认true if (refresh) &#123; refresh(); &#125;&#125; 构造器首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext: 1234567public AbstractApplicationContext(ApplicationContext parent) &#123; this(); setParent(parent);&#125;public AbstractApplicationContext() &#123; this.resourcePatternResolver = getResourcePatternResolver();&#125; getResourcePatternResolver: 123protected ResourcePatternResolver getResourcePatternResolver() &#123; return new PathMatchingResourcePatternResolver(this);&#125; PathMatchingResourcePatternResolver支持Ant风格的路径解析。 设置配置文件路径即AbstractRefreshableConfigApplicationContext.setConfigLocations: 1234567891011public void setConfigLocations(String... locations) &#123; if (locations != null) &#123; Assert.noNullElements(locations, &quot;Config locations must not be null&quot;); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) &#123; this.configLocations[i] = resolvePath(locations[i]).trim(); &#125; &#125; else &#123; this.configLocations = null; &#125;&#125; resolvePath: 123protected String resolvePath(String path) &#123; return getEnvironment().resolveRequiredPlaceholders(path);&#125; 此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);那么classpath:就是需要被解析的。 getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment: 123protected ConfigurableEnvironment createEnvironment() &#123; return new StandardEnvironment();&#125; Environment接口继承体系: Environmen接口代表了当前应用所处的环境。从此接口的方法可以看出，其主要和profile、Property相关。 ProfileSpring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。Spring容器管理的所有bean都是和一个profile绑定在一起的。使用了Profile的配置文件示例: 123456789&lt;beans profile=&quot;develop&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-develop.properties&quot;/&gt; &lt;/beans&gt; &lt;beans profile=&quot;production&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-production.properties&quot;/&gt; &lt;/beans&gt; &lt;beans profile=&quot;test&quot;&gt; &lt;context:property-placeholder location=&quot;classpath*:jdbc-test.properties&quot;/&gt; &lt;/beans&gt; 在启动代码中可以用如下代码设置活跃(当前使用的)Profile: 1context.getEnvironment().setActiveProfiles(&quot;dev&quot;); 当然使用的方式还有很多(比如注解)，参考: spring3.1 profile 配置不同的环境 Spring Profiles example Property这里的Property指的是程序运行时的一些参数，引用注释: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on. Environment构造器1234private final MutablePropertySources propertySources = new MutablePropertySources(this.logger);public AbstractEnvironment() &#123; customizePropertySources(this.propertySources);&#125; PropertySources接口继承体系: 此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。 StandardEnvironment.customizePropertySources: 1234567891011/** System environment property source name: &#123;@value&#125; */public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = &quot;systemEnvironment&quot;;/** JVM system properties property source name: &#123;@value&#125; */public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = &quot;systemProperties&quot;;@Overrideprotected void customizePropertySources(MutablePropertySources propertySources) &#123; propertySources.addLast(new MapPropertySource (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties())); propertySources.addLast(new SystemEnvironmentPropertySource (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));&#125; PropertySource接口PropertySource接口代表了键值对的Property来源。继承体系： AbstractEnvironment.getSystemProperties: 123456789101112131415161718192021222324@Overridepublic Map&lt;String, Object&gt; getSystemProperties() &#123; try &#123; return (Map) System.getProperties(); &#125; catch (AccessControlException ex) &#123; return (Map) new ReadOnlySystemAttributesMap() &#123; @Override protected String getSystemAttribute(String attributeName) &#123; try &#123; return System.getProperty(attributeName); &#125; catch (AccessControlException ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(format(&quot;Caught AccessControlException when accessing system &quot; + &quot;property [%s]; its value will be returned [null]. Reason: %s&quot;, attributeName, ex.getMessage())); &#125; return null; &#125; &#125; &#125;; &#125;&#125; 这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。 getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。 路径Placeholder处理AbstractEnvironment.resolveRequiredPlaceholders: 12345@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; //text即配置文件路径，比如classpath:config.xml return this.propertyResolver.resolveRequiredPlaceholders(text);&#125; propertyResolver是一个PropertySourcesPropertyResolver对象: 12private final ConfigurablePropertyResolver propertyResolver = new PropertySourcesPropertyResolver(this.propertySources); PropertyResolver接口PropertyResolver继承体系(排除Environment分支): 此接口正是用来解析PropertyResource。 解析AbstractPropertyResolver.resolveRequiredPlaceholders: 123456789101112@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; if (this.strictHelper == null) &#123; this.strictHelper = createPlaceholderHelper(false); &#125; return doResolvePlaceholders(text, this.strictHelper);&#125;private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) &#123; //三个参数分别是$&#123;, &#125;, : return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, ignoreUnresolvablePlaceholders);&#125; doResolvePlaceholders： 123456789private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) &#123; //PlaceholderResolver接口依然是策略模式的体现 return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() &#123; @Override public String resolvePlaceholder(String placeholderName) &#123; return getPropertyAsRawString(placeholderName); &#125; &#125;);&#125; 其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写: 123System.setProperty(&quot;spring&quot;, &quot;classpath&quot;);ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;$&#123;spring&#125;:config.xml&quot;);SimpleBean bean = context.getBean(SimpleBean.class); 这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty: 12345678910111213@Overrideprotected String getPropertyAsRawString(String key) &#123; return getProperty(key, String.class, false);&#125;protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); return value; &#125; &#125; return null;&#125; 很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。 注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。 refreshSpring bean解析就在此方法，所以单独提出来。 AbstractApplicationContext.refresh: 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &apos;active&apos; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&apos;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; prepareRefresh1234567891011121314protected void prepareRefresh() &#123; this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); // Initialize any placeholder property sources in the context environment //空实现 initPropertySources(); // Validate that all properties marked as required are resolvable // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125; 属性校验AbstractEnvironment.validateRequiredProperties: 1234@Overridepublic void validateRequiredProperties() throws MissingRequiredPropertiesException &#123; this.propertyResolver.validateRequiredProperties();&#125; AbstractPropertyResolver.validateRequiredProperties: 123456789101112@Overridepublic void validateRequiredProperties() &#123; MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException(); for (String key : this.requiredProperties) &#123; if (this.getProperty(key) == null) &#123; ex.addMissingRequiredProperty(key); &#125; &#125; if (!ex.getMissingRequiredProperties().isEmpty()) &#123; throw ex; &#125;&#125; requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。 BeanFactory创建由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory: 12345678910111213141516@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; //如果已经存在，那么销毁之前的 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; //创建了一个DefaultListableBeanFactory对象 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125;&#125; BeanFactory接口此接口实际上就是Bean容器，其继承体系: BeanFactory定制AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现: 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; //默认false，不允许覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; //默认false，不允许循环引用 beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; Bean加载AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了: 123456789101112131415@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context&apos;s // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. //默认空实现 initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; EntityResolver此处只说明用到的部分继承体系: EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。 BeanDefinitionReader继承体系: 路径解析(Ant)1234567891011protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); //here if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; AbstractBeanDefinitionReader.loadBeanDefinitions: 123456789@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123; Assert.notNull(locations, &quot;Location array must not be null&quot;); int counter = 0; for (String location : locations) &#123; counter += loadBeanDefinitions(location); &#125; return counter;&#125; 之后调用: 12345678910111213141516171819202122232425262728293031//第二个参数为空public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) &#123; ResourceLoader resourceLoader = getResourceLoader(); //参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口 if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( &quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; return loadCount; &#125;&#125; getResource的实现在AbstractApplicationContext： 12345@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; //构造器中初始化，PathMatchingResourcePatternResolver对象 return this.resourcePatternResolver.getResources(locationPattern);&#125; PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。 123456789101112131415161718192021222324252627282930@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); //classpath: if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible) //matcher是一个AntPathMatcher对象 if (getPathMatcher().isPattern(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // Only look for a pattern after a prefix here // (to not get fooled by a pattern symbol in a strange prefix). int prefixEnd = locationPattern.indexOf(&quot;:&quot;) + 1; if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; isPattern: 1234@Overridepublic boolean isPattern(String path) &#123; return (path.indexOf(&apos;*&apos;) != -1 || path.indexOf(&apos;?&apos;) != -1);&#125; 可以看出配置文件路径是支持ant风格的，也就是可以这么写: 1new ClassPathXmlApplicationContext(&quot;con*.xml&quot;); 具体怎么解析ant风格的就不写了。 配置文件加载入口方法在AbstractBeanDefinitionReader的217行: 1234//加载Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);//解析int loadCount = loadBeanDefinitions(resources); 最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法: 1234@Overridepublic int loadBeanDefinitions(Resource resource) &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125; Resource是代表一种资源的接口，其类图: EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。 之后关键的源码只有两行: 12345public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); InputSource inputSource = new InputSource(inputStream); return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125; InputSource是org.xml.sax的类。 doLoadBeanDefinitions： 1234protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource);&#125; doLoadDocument: 1234protected Document doLoadDocument(InputSource inputSource, Resource resource) &#123; return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。 校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。 NamespaceAware默认false，因为默认配置了校验为true。 DefaultDocumentLoader.loadDocument: 12345678@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) &#123; //这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; createDocumentBuilderFactory比较有意思: 12345678910111213141516protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(namespaceAware); if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123; //此方法设为true仅对dtd有效，xsd(schema)无效 factory.setValidating(true); if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123; // Enforce namespace aware for XSD... //开启xsd(schema)支持 factory.setNamespaceAware(true); //这个也是Java支持Schema的套路，可以问度娘 factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); &#125; &#125; return factory;&#125; Bean解析XmlBeanDefinitionReader.registerBeanDefinitions: 123456public int registerBeanDefinitions(Document doc, Resource resource) &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; createBeanDefinitionDocumentReader: 12345protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanDefinitionDocumentReader.class.cast //反射 (BeanUtils.instantiateClass(this.documentReaderClass));&#125; documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。 注意cast方法，代替了强转。 createReaderContext： 1234public XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());&#125; problemReporter是一个FailFastProblemReporter对象。 eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。 sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。 getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。 XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。 DefaultBeanDefinitionDocumentReader.registerBeanDefinitions: 123456@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; doRegisterBeanDefinitions: 12345678910111213141516171819202122protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); //默认的命名空间即 //http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) &#123; //检查profile属性 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; //profile属性可以以,分割 String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的: 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans&gt; &lt;bean class=&quot;base.SimpleBean&quot;&gt;&lt;/bean&gt; &lt;beans&gt; &lt;bean class=&quot;java.lang.Object&quot;&gt;&lt;/bean&gt; &lt;/beans&gt;&lt;/beans&gt; xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样: 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&gt;&lt;/beans&gt; xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。 注意一下profile的检查, AbstractEnvironment.acceptsProfiles: 1234567891011121314@Overridepublic boolean acceptsProfiles(String... profiles) &#123; Assert.notEmpty(profiles, &quot;Must specify at least one profile&quot;); for (String profile : profiles) &#123; if (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(0) == &apos;!&apos;) &#123; if (!isProfileActive(profile.substring(1))) &#123; return true; &#125; &#125; else if (isProfileActive(profile)) &#123; return true; &#125; &#125; return false;&#125; 原理很简单，注意从源码可以看出，profile属性支持!取反。 preProcessXml方法是个空实现，供子类去覆盖，目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会, 想的真周到。 DefaultBeanDefinitionDocumentReader.parseBeanDefinitions： 123456789101112131415161718protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 可见，对于非默认命名空间的元素交由delegate处理。 默认命名空间解析即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement: 12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //&quot;import&quot; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; import写法示例: 12&lt;import resource=&quot;CTIContext.xml&quot; /&gt;&lt;import resource=&quot;customerContext.xml&quot; /&gt; importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。 alias加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义: 1&lt;alias name=&quot;componentA-dataSource&quot; alias=&quot;componentB-dataSource&quot;/&gt; processAliasRegistration核心源码: 123456protected void processAliasRegistration(Element ele) &#123; String name = ele.getAttribute(NAME_ATTRIBUTE); String alias = ele.getAttribute(ALIAS_ATTRIBUTE); getReaderContext().getRegistry().registerAlias(name, alias); getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));&#125; 从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry: 12345678910111213141516171819202122232425@Overridepublic void registerAlias(String name, String alias) &#123; Assert.hasText(name, &quot;&apos;name&apos; must not be empty&quot;); Assert.hasText(alias, &quot;&apos;alias&apos; must not be empty&quot;); //名字和别名一样 if (alias.equals(name)) &#123; //ConcurrentHashMap this.aliasMap.remove(alias); &#125; else &#123; String registeredName = this.aliasMap.get(alias); if (registeredName != null) &#123; if (registeredName.equals(name)) &#123; // An existing alias - no need to re-register return; &#125; if (!allowAliasOverriding()) &#123; throw new IllegalStateException (&quot;Cannot register alias &apos;&quot; + alias + &quot;&apos; for name &apos;&quot; + name + &quot;&apos;: It is already registered for name &apos;&quot; + registeredName + &quot;&apos;.&quot;); &#125; &#125; checkForAliasCircle(name, alias); this.aliasMap.put(alias, name); &#125;&#125; 所以别名关系的保存使用Map完成，key为别名，value为本来的名字。 beanbean节点是Spring最最常见的节点了。 DefaultBeanDefinitionDocumentReader.processBeanDefinition: 1234567891011121314151617protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition (bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(&quot;Failed to register bean definition with name &apos;&quot; + bdHolder.getBeanName() + &quot;&apos;&quot;, ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; id &amp; name处理最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。 首先获取到id和name属性，name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做。 1234567891011121314151617181920String id = ele.getAttribute(ID_ATTRIBUTE);String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();if (StringUtils.hasLength(nameAttr)) &#123; //按,分隔 String[] nameArr = StringUtils.tokenizeToStringArray (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr));&#125;String beanName = id;if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; //name的第一个值作为id beanName = aliases.remove(0);&#125;//默认nullif (containingBean == null) &#123; //校验id是否已重复，如果重复直接抛异常 //校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set checkNameUniqueness(beanName, aliases, ele);&#125; beanName生成如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement: 123beanName = this.readerContext.generateBeanName(beanDefinition);String beanClassName = beanDefinition.getBeanClassName();aliases.add(beanClassName); 可见，Spring同时会把类名作为其别名。 最终调用的是BeanDefinitionReaderUtils.generateBeanName: 12345678910111213141516171819202122232425262728public static String generateBeanName( BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) &#123; String generatedBeanName = definition.getBeanClassName(); if (generatedBeanName == null) &#123; if (definition.getParentName() != null) &#123; generatedBeanName = definition.getParentName() + &quot;$child&quot;; //工厂方法产生的bean &#125; else if (definition.getFactoryBeanName() != null) &#123; generatedBeanName = definition.getFactoryBeanName() + &quot;$created&quot;; &#125; &#125; String id = generatedBeanName; if (isInnerBean) &#123; // Inner bean: generate identity hashcode suffix. id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); &#125; else &#123; // Top-level bean: use plain class name. // Increase counter until the id is unique. int counter = -1; //用类名#自增的数字命名 while (counter == -1 || registry.containsBeanDefinition(id)) &#123; counter++; id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter; &#125; &#125; return id;&#125; bean解析还是分部分说明(parseBeanDefinitionElement)。 首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。 123456789String className = null;if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;String parent = null;if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE);&#125;AbstractBeanDefinition bd = createBeanDefinition(className, parent); BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition: 1234567891011121314public static AbstractBeanDefinition createBeanDefinition( String parentName, String className, ClassLoader classLoader) &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; 之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中: 1parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 之后解析bean的decription子元素: 123&lt;bean id=&quot;b&quot; name=&quot;one, two&quot; class=&quot;base.SimpleBean&quot;&gt; &lt;description&gt;SimpleBean&lt;/description&gt;&lt;/bean&gt; 就仅仅是个描述。 然后是meta子元素的解析，meta元素在xml配置文件里是这样的: 123&lt;bean id=&quot;b&quot; name=&quot;one, two&quot; class=&quot;base.SimpleBean&quot;&gt; &lt;meta key=&quot;name&quot; value=&quot;skywalker&quot;/&gt;&lt;/bean&gt; 注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码: 12345678910111213141516public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) &#123; NodeList nl = ele.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123; Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); //就是一个key, value的载体，无他 BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); //sourceExtractor默认是NullSourceExtractor，返回的是空 attribute.setSource(extractSource(metaElement)); attributeAccessor.addMetadataAttribute(attribute); &#125; &#125;&#125; AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。 lookup-method解析： 此标签的作用在于当一个bean的某个方法被设置为lookup-method后，每次调用此方法时，都会返回一个新的指定bean的对象。用法示例: 12345&lt;bean id=&quot;apple&quot; class=&quot;cn.com.willchen.test.di.Apple&quot; scope=&quot;prototype&quot;/&gt;&lt;!--水果盘--&gt;&lt;bean id=&quot;fruitPlate&quot; class=&quot;cn.com.willchen.test.di.FruitPlate&quot;&gt; &lt;lookup-method name=&quot;getFruit&quot; bean=&quot;apple&quot;/&gt;&lt;/bean&gt; 数据保存在Set中，对应的类是MethodOverrides。可以参考: Spring - lookup-method方式实现依赖注入 replace-mothod解析: 此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。 配置文件示例: 123456&lt;bean name=&quot;replacer&quot; class=&quot;springroad.deomo.chap4.MethodReplace&quot; /&gt; &lt;bean name=&quot;testBean&quot; class=&quot;springroad.deomo.chap4.LookupMethodBean&quot;&gt; &lt;replaced-method name=&quot;test&quot; replacer=&quot;replacer&quot;&gt; &lt;arg-type match=&quot;String&quot; /&gt; &lt;/replaced-method&gt; &lt;/bean&gt; arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: SPRING.NET 1.3.2 学习20–方法注入之替换方法注入 解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList专门用于保存arg-type。 构造参数(constructor-arg)解析: 作用一目了然，使用示例: 12345&lt;bean class=&quot;base.SimpleBean&quot;&gt; &lt;constructor-arg&gt; &lt;value type=&quot;java.lang.String&quot;&gt;Cat&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map的形式保存，反之，以List的形式保存。 property解析: 非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例: 123&lt;bean class=&quot;base.SimpleBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;skywalker&quot; /&gt;&lt;/bean&gt; value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。 qualifier解析: 配置示例: 1234567891011&lt;bean class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;skywalker&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/property&gt; &lt;qualifier type=&quot;org.springframework.beans.factory.annotation.Qualifier&quot; value=&quot;student&quot; /&gt;&lt;/bean&gt; &lt;bean class=&quot;base.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;seaswalker&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt; &lt;qualifier value=&quot;student_2&quot;&gt;&lt;/qualifier&gt;&lt;/bean&gt;&lt;bean class=&quot;base.SimpleBean&quot; /&gt; SimpleBean部分源码: 123@Autowired@Qualifier(&quot;student&quot;)private Student student; 此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如: 123&lt;qualifier type=&quot;org.springframework.beans.factory.annotation.Qualifier&quot; value=&quot;student&quot;&gt; &lt;attribute key=&quot;id&quot; value=&quot;1&quot;/&gt;&lt;/qualifier&gt; 貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。 Bean装饰这部分是针对其它schema的属性以及子节点，比如: 123&lt;bean class=&quot;base.Student&quot; primary=&quot;true&quot;&gt; &lt;context:property-override /&gt;&lt;/bean&gt; 没见过这种用法，留个坑。 Bean注册BeanDefinitionReaderUtils.registerBeanDefinition: 12345678910111213public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &#123; // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事: 12345@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName);&#125; 一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。 ComponentRegistered事件触发: 默认是个空实现，前面说过了。 BeanDefiniton数据结构BeanDefiniton数据结构如下图: beansbeans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。 其它命名空间解析入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空): 12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。 其resolve方法: 1234567891011121314151617@Overridepublic NamespaceHandler resolve(String namespaceUri) &#123; Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125;&#125; 容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回。 NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例: 12345http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandlerhttp\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler NamespaceHandler继承体系 initresolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。此接口用以解析顶层(beans下)的非默认命名空间元素，比如。 所以这样逻辑就很容易理解了: 每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程。 此部分较为重要，所以重新开始大纲。 BeanFactory数据结构BeanDefinition在BeanFactory中的主要数据结构如下图: prepareBeanFactory此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面: BeanExpressionResolver此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法: 1Object evaluate(String value, BeanExpressionContext evalContext) prepareBeanFactory将一个此对象放入BeanFactory: 1beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图: 这便是Spring3.0开始出现的Spel表达式的解释器。 PropertyEditorRegistrar此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法: 1registerCustomEditors(PropertyEditorRegistry registry) 实现也只有一个: ResourceEditorRegistrar。 在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。 prepareBeanFactory: 1beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。 我们有两种方式可以添加自定义PropertyEditor: 通过context.getBeanFactory().registerCustomEditor 通过Spring配置文件: 1234567&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt; &lt;property name=&quot;customEditors&quot;&gt; &lt;map&gt; &lt;entry key=&quot;base.Cat&quot; value=&quot;base.CatEditor&quot; /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 参考: 深入理解JavaBean(2)：属性编辑器PropertyEditor 环境注入在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory: 1beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法: 1234567891011private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; //.... &#125;&#125; 依赖解析忽略此部分设置哪些接口在进行依赖注入的时候应该被忽略: 12345beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);beanFactory.ignoreDependencyInterface(MessageSourceAware.class);beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);beanFactory.ignoreDependencyInterface(EnvironmentAware.class); bean伪装有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下: 1234beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);beanFactory.registerResolvableDependency(ResourceLoader.class, this);beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);beanFactory.registerResolvableDependency(ApplicationContext.class, this); 伪装关系保存在一个Map]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[何谓悲观锁与乐观锁]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F04%2F18%2F%E4%BD%95%E8%B0%93%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[何谓悲观锁与乐观锁 乐观锁对应于生活中乐观的人总是想着事情往好的方向发展，悲观锁对应于生活中悲观的人总是想着事情往坏的方向发展。这两种人各有优缺点，不能不以场景而定说一种人好于另外一种人。 悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 两种锁的使用场景从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 乐观锁常见的两种实现方式 乐观锁一般会使用版本号机制或CAS算法实现。 1. 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段，当前值为 1 ；而当前帐户余额字段（ balance ）为 $100 。 操作员 A 此时将其读出（ version=1 ），并从其帐户余额中扣除 $50（ $100-$50 ）。 在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version=1 ），并从其帐户余额中扣除 $20 （ $100-$20 ）。 操作员 A 完成了修改工作，将数据版本号加一（ version=2 ），连同帐户扣除后余额（ balance=$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 操作员 B 完成了操作，也将版本号加一（ version=2 ）试图向数据库提交数据（ balance=$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。 这样，就避免了操作员 B 用基于 version=1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。 2. CAS算法即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。 关于自旋锁，大家可以看一下这篇文章，非常不错：《 面试必备之深入理解自旋锁》 乐观锁的缺点 ABA 问题是乐观锁一个常见的问题 1 ABA 问题如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。 JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 2 循环时间长开销大自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。 3 只能保证一个共享变量的原子操作CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。 CAS与synchronized的使用情景 简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多） 对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 003 无重复字符的最长子串]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F01%2F25%2Fleetcode003TwoSum%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[继续 问题给定一个字符串，找出不含有重复字符的最长子串的长度。 示例：给定 &quot;abcabcbb&quot; ，没有重复字符的最长子串是 &quot;abc&quot; ，那么长度就是3。给定 &quot;bbbbb&quot; ，最长的子串就是 &quot;b&quot; ，长度是1。给定 &quot;pwwkew&quot; ，最长子串是 &quot;wke&quot; ，长度是3。请注意答案必须是一个子串，&quot;pwke&quot; 是 子序列 而不是子串。 解答滑动窗口：定义空集合，之后左边i先固定，右边j向右走，判断集合中是否存在j所对应的字符，若不存在，则添加，且j++，同时最长子串长度也更新；若集合中已存在j所对应的字符，则集合移除左边i对应的字符，i++ 向右走一步。 12345678910111213141516class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n = s.length(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int maxLen = 0, i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; n) &#123; if(!set.contains(s.charAt(j))) &#123; set.add(s.charAt(j++)); maxLen = Math.max(maxLen, j - i); &#125; else &#123; set.remove(s.charAt(i++)); &#125; &#125; return maxLen; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年好啊]]></title>
    <url>%2Fhaianzwh.github.io%2F2018%2F01%2F01%2F%E6%96%B0%E5%B9%B4%E5%A5%BD%E5%95%8A%2F</url>
    <content type="text"><![CDATA[新年好！]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 002 Add Two Numbers]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F25%2FLeetCode002AddTwoNumbers%2F</url>
    <content type="text"><![CDATA[学习记录 问题给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解答123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode retList = new ListNode(0); ListNode p = l1, q = l2, r = retList; boolean flag = false; while(p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int temp = x + y; if(flag) &#123; temp += 1; flag = false; &#125; if(temp &gt; 9) &#123; flag = true; temp -= 10; &#125; r.next = new ListNode(temp); r = r.next; if(p != null) p = p.next; if(q != null) q = q.next; &#125; if(flag) &#123; r.next = new ListNode(1); &#125; return retList.next; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap(JDK1.8)源码学习]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F12%2FHashMap(JDK1.8)%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HashMap 简介HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。 JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。 底层数据结构分析JDK1.8之前JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。 JDK 1.8 HashMap 的 hash 方法源码: JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。 1234567 static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 对比一下 JDK1.7的 HashMap 的 hash 方法源码. 12345678static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 JDK1.8之后相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 类的属性： 12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 填充因子 final float loadFactor;&#125; loadFactor加载因子 loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，load Factor越小，也就是趋近于0， loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 threshold threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 Node节点类源码: 123456789101112131415161718192021222324252627282930313233343536373839// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 树节点类源码: 12345678910111213141516static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; HashMap源码分析构造方法 123456789101112131415161718192021222324252627// 默认构造函数。public More ...HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; // 包含另一个“Map”的构造函数 public More ...HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 &#125; // 指定“容量大小”的构造函数 public More ...HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 指定“容量大小”和“加载因子”的构造函数 public More ...HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; putMapEntries方法： 123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; put方法HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 对putVal方法添加元素的分析如下： ①如果定位到的数组位置没有元素 就直接插入。 ②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125; 我们再来对比一下 JDK1.7 put方法的代码 对于put方法的分析如下： ①如果定位到的数组位置没有元素 就直接插入。 ②如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插法插入元素。 12345678910111213141516171819202122public V put(K key, V value) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; // 先遍历 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); // 再插入 return null;&#125; get方法12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize方法进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; HashMap常用方法测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package map;import java.util.Collection;import java.util.HashMap;import java.util.Set;public class HashMapDemo &#123; public static void main(String[] args) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 键不能重复，值可以重复 map.put(&quot;san&quot;, &quot;张三&quot;); map.put(&quot;si&quot;, &quot;李四&quot;); map.put(&quot;wu&quot;, &quot;王五&quot;); map.put(&quot;wang&quot;, &quot;老王&quot;); map.put(&quot;wang&quot;, &quot;老王2&quot;);// 老王被覆盖 map.put(&quot;lao&quot;, &quot;老王&quot;); System.out.println(&quot;-------直接输出hashmap:-------&quot;); System.out.println(map); /** * 遍历HashMap */ // 1.获取Map中的所有键 System.out.println(&quot;-------foreach获取Map中所有的键:------&quot;); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+&quot; &quot;); &#125; System.out.println();//换行 // 2.获取Map中所有值 System.out.println(&quot;-------foreach获取Map中所有的值:------&quot;); Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+&quot; &quot;); &#125; System.out.println();//换行 // 3.得到key的值的同时得到key所对应的值 System.out.println(&quot;-------得到key的值的同时得到key所对应的值:-------&quot;); Set&lt;String&gt; keys2 = map.keySet(); for (String key : keys2) &#123; System.out.print(key + &quot;：&quot; + map.get(key)+&quot; &quot;); &#125; /** * 另外一种不常用的遍历方式 */ // 当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + &quot;--&quot; + entry.getValue()); &#125; /** * HashMap其他常用方法 */ System.out.println(&quot;after map.size()：&quot;+map.size()); System.out.println(&quot;after map.isEmpty()：&quot;+map.isEmpty()); System.out.println(map.remove(&quot;san&quot;)); System.out.println(&quot;after map.remove()：&quot;+map); System.out.println(&quot;after map.get(si)：&quot;+map.get(&quot;si&quot;)); System.out.println(&quot;after map.containsKey(si)：&quot;+map.containsKey(&quot;si&quot;)); System.out.println(&quot;after containsValue(李四)：&quot;+map.containsValue(&quot;李四&quot;)); System.out.println(map.replace(&quot;si&quot;, &quot;李四2&quot;)); System.out.println(&quot;after map.replace(si, 李四2):&quot;+map); &#125;&#125;]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList 源码学习]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F12%2F04%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[简介LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性; LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法： 1List list=Collections.synchronizedList(new LinkedList(...)); 内部结构分析如下图所示： 看完了图之后，我们再看LinkedList类中的一个内部私有类Node就很好理解了： 1234567891011private static class Node&lt;E&gt; &#123; E item;//节点值 Node&lt;E&gt; next;//后继节点 Node&lt;E&gt; prev;//前驱节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。 LinkedList源码分析构造方法空构造方法： 12public LinkedList() &#123;&#125; 用已有的集合创建链表的构造方法： 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; add方法add(E e) 方法：将元素添加到链表尾部 123456789101112131415161718public boolean add(E e) &#123; linkLast(e);//这里就只调用了这一个方法 return true; &#125; /** * 链接使e作为最后一个元素。 */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode;//新建节点 if (l == null) first = newNode; else l.next = newNode;//指向后继元素也就是指向下一个元素 size++; modCount++; &#125; add(int index,E e)：在指定位置添加元素 12345678public void add(int index, E element) &#123; checkPositionIndex(index); //检查索引是否处于[0-size]之间 if (index == size)//添加在链表尾部 linkLast(element); else//添加在链表中间 linkBefore(element, node(index)); &#125; linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node addAll(Collection c )：将集合插入到链表尾部 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; addAll(int index, Collection c)： 将集合从指定位置开始插入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //1:检查index范围是否在size之内 checkPositionIndex(index); //2:toArray()方法把集合的数据存到对象数组中 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //3：得到插入位置的前驱节点和后继节点 Node&lt;E&gt; pred, succ; //如果插入位置为尾部，前驱节点为last，后继节点为null if (index == size) &#123; succ = null; pred = last; &#125; //否则，调用node()方法得到后继节点，再得到前驱节点 else &#123; succ = node(index); pred = succ.prev; &#125; // 4：遍历数据将数据插入 for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; //创建新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果插入位置在链表头部 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果插入位置在尾部，重置last节点 if (succ == null) &#123; last = pred; &#125; //否则，将插入的链表与先前链表连接起来 else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 上面可以看出addAll方法通常包括下面四个步骤： 检查index范围是否在size之内 toArray()方法把集合的数据存到对象数组中 得到插入位置的前驱和后继节点 遍历数据，将数据插入到指定位置 addFirst(E e)： 将元素添加到链表头部 12345678910111213141516 public void addFirst(E e) &#123; linkFirst(e); &#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//新建节点，以头节点为后继节点 first = newNode; //如果链表为空，last节点也指向该节点 if (f == null) last = newNode; //否则，将头节点的前驱指针指向新节点，也就是指向前一个元素 else f.prev = newNode; size++; modCount++; &#125; addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样 123public void addLast(E e) &#123; linkLast(e); &#125; 根据位置取数据的方法get(int index)：：根据指定索引返回数据 123456public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item; &#125; 获取头节点（index=0）数据方法: 123456789101112131415161718public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item; &#125;public E element() &#123; return getFirst(); &#125;public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125; 区别： getFirst(),element(),peek(),peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常 element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException 获取尾节点（index=-1）数据方法: 12345678910public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item; &#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item; &#125; 两者区别： getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。 根据对象得到索引的方法int indexOf(Object o)： 从头遍历找 12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; //从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125; int lastIndexOf(Object o)： 从尾遍历找 12345678910111213141516171819public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; //从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; 检查链表是否包含某对象的方法：contains(Object o)： 检查对象o是否存在于链表中 123public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; ###删除方法 remove() ,removeFirst(),pop(): 删除头节点 123456789101112public E pop() &#123; return removeFirst(); &#125;public E remove() &#123; return removeFirst(); &#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125; removeLast(),pollLast(): 删除尾节点 12345678910public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l); &#125; 区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。 remove(Object o): 删除指定元素 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; //如果删除对象为null if (o == null) &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (x.item == null) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; else &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (o.equals(x.item)) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; return false; &#125; 当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。 unlink(Node x) 方法： 123456789101112131415161718192021222324252627E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next;//得到后继节点 final Node&lt;E&gt; prev = x.prev;//得到前驱节点 //删除前驱指针 if (prev == null) &#123; first = next;如果删除的节点是头节点,令头节点指向该节点的后继节点 &#125; else &#123; prev.next = next;//将前驱节点的后继节点指向后继节点 x.prev = null; &#125; //删除后继指针 if (next == null) &#123; last = prev;//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点 &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; remove(int index)：删除指定位置的元素 123456public E remove(int index) &#123; //检查index范围 checkElementIndex(index); //将节点删除 return unlink(node(index)); &#125; LinkedList类常用方法测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121package list;import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] srgs) &#123; //创建存放int类型的linkedList LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); /************************** linkedList的基本操作 ************************/ linkedList.addFirst(0); // 添加元素到列表开头 linkedList.add(1); // 在列表结尾添加元素 linkedList.add(2, 2); // 在指定位置添加元素 linkedList.addLast(3); // 添加元素到列表结尾 System.out.println(&quot;LinkedList（直接输出的）: &quot; + linkedList); System.out.println(&quot;getFirst()获得第一个元素: &quot; + linkedList.getFirst()); // 返回此列表的第一个元素 System.out.println(&quot;getLast()获得第最后一个元素: &quot; + linkedList.getLast()); // 返回此列表的最后一个元素 System.out.println(&quot;removeFirst()删除第一个元素并返回: &quot; + linkedList.removeFirst()); // 移除并返回此列表的第一个元素 System.out.println(&quot;removeLast()删除最后一个元素并返回: &quot; + linkedList.removeLast()); // 移除并返回此列表的最后一个元素 System.out.println(&quot;After remove:&quot; + linkedList); System.out.println(&quot;contains()方法判断列表是否包含1这个元素:&quot; + linkedList.contains(1)); // 判断此列表包含指定元素，如果是，则返回true System.out.println(&quot;该linkedList的大小 : &quot; + linkedList.size()); // 返回此列表的元素个数 /************************** 位置访问操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素 System.out.println(&quot;After set(1, 3):&quot; + linkedList); System.out.println(&quot;get(1)获得指定位置（这里为1）的元素: &quot; + linkedList.get(1)); // 返回此列表中指定位置处的元素 /************************** Search操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.add(3); System.out.println(&quot;indexOf(3): &quot; + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引 System.out.println(&quot;lastIndexOf(3): &quot; + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引 /************************** Queue操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); System.out.println(&quot;peek(): &quot; + linkedList.peek()); // 获取但不移除此列表的头 System.out.println(&quot;element(): &quot; + linkedList.element()); // 获取但不移除此列表的头 linkedList.poll(); // 获取并移除此列表的头 System.out.println(&quot;After poll():&quot; + linkedList); linkedList.remove(); System.out.println(&quot;After remove():&quot; + linkedList); // 获取并移除此列表的头 linkedList.offer(4); System.out.println(&quot;After offer(4):&quot; + linkedList); // 将指定元素添加到此列表的末尾 /************************** Deque操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.offerFirst(2); // 在此列表的开头插入指定的元素 System.out.println(&quot;After offerFirst(2):&quot; + linkedList); linkedList.offerLast(5); // 在此列表末尾插入指定的元素 System.out.println(&quot;After offerLast(5):&quot; + linkedList); System.out.println(&quot;peekFirst(): &quot; + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素 System.out.println(&quot;peekLast(): &quot; + linkedList.peekLast()); // 获取但不移除此列表的第一个元素 linkedList.pollFirst(); // 获取并移除此列表的第一个元素 System.out.println(&quot;After pollFirst():&quot; + linkedList); linkedList.pollLast(); // 获取并移除此列表的最后一个元素 System.out.println(&quot;After pollLast():&quot; + linkedList); linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头） System.out.println(&quot;After push(2):&quot; + linkedList); linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素） System.out.println(&quot;After pop():&quot; + linkedList); linkedList.add(3); linkedList.removeFirstOccurrence(3); // 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表） System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList); linkedList.removeLastOccurrence(3); // 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表） System.out.println(&quot;After removeFirstOccurrence(3):&quot; + linkedList); /************************** 遍历操作 ************************/ System.out.println(&quot;-----------------------------------------&quot;); linkedList.clear(); for (int i = 0; i &lt; 100000; i++) &#123; linkedList.add(i); &#125; // 迭代器遍历 long start = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;Iterator：&quot; + (end - start) + &quot; ms&quot;); // 顺序遍历(随机遍历) start = System.currentTimeMillis(); for (int i = 0; i &lt; linkedList.size(); i++) &#123; linkedList.get(i); &#125; end = System.currentTimeMillis(); System.out.println(&quot;for：&quot; + (end - start) + &quot; ms&quot;); // 另一种for循环遍历 start = System.currentTimeMillis(); for (Integer i : linkedList) ; end = System.currentTimeMillis(); System.out.println(&quot;for2：&quot; + (end - start) + &quot; ms&quot;); // 通过pollFirst()或pollLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;(); temp1.addAll(linkedList); start = System.currentTimeMillis(); while (temp1.size() != 0) &#123; temp1.pollFirst(); &#125; end = System.currentTimeMillis(); System.out.println(&quot;pollFirst()或pollLast()：&quot; + (end - start) + &quot; ms&quot;); // 通过removeFirst()或removeLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;(); temp2.addAll(linkedList); start = System.currentTimeMillis(); while (temp2.size() != 0) &#123; temp2.removeFirst(); &#125; end = System.currentTimeMillis(); System.out.println(&quot;removeFirst()或removeLast()：&quot; + (end - start) + &quot; ms&quot;); &#125;&#125;]]></content>
      <categories>
        <category>源码剖析</category>
      </categories>
      <tags>
        <tag>源码剖析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 001 TwoSum]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F11%2F25%2Fleetcode001TwoSum%20-%20%E5%89%AF%E6%9C%AC%20(8)%2F</url>
    <content type="text"><![CDATA[本文给出了刷题，记录学习 问题给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例： 1234给定nums = [2,7,11,15]，目标= 9因为nums [0] + nums [1] = 2 + 7 = 9所以返回[0,1] 解答方法一：暴力法遍历数组中每个元素x，是否查找存在一个值与target-x相等的目标元素 123456789101112class Solution &#123; public int [] twoSum（int [] nums，int target）&#123; for（int i = 0; i &lt;nums.length-1; i ++）&#123; for（int j = i + 1; j &lt;nums.length; j ++）&#123; if（nums [j] == target - nums [i]）&#123; return new int [] &#123;i，j&#125;; &#125; &#125; &#125; 抛出新的IllegalArgumentException（“No two sum solution”）; &#125;&#125; 复杂度分析： 时间复杂度： O （n2）O(n2) Σi = 0n - 2Σj = i + 1n - 11 = Σi = 0n - 2（n - 1 ）- （i + 1 ）+ 1= Σi = 0n - 2（n - i - 1 ）= （n - 1 ）+ （n - 2 ）+ … + 1 = n （n - 1 ）2∑i=0n−2∑j=i+1n−11=∑i=0n−2(n−1)−(i+1)+1=∑i=0n−2(n−i−1)=(n−1)+(n−2)+…+1=n(n−1)2 空间复杂度：O （1 ）O(1) 方法二：哈希表采用哈希表，通过以空间换时间，来保存数组中每个元素与其索引的对应关系。 t a r gë 吨- ñ ü 中号小号[ 我]target−nums[i]Ñ ü 中号小号[ 我]nums[i] 123456789101112131415class Solution &#123; public int [] twoSum（int [] nums，int target）&#123; Map &lt;Integer，Integer&gt; map = new HashMap &lt;&gt;（）; for（int i = 0; i &lt;nums.length; i ++）&#123; map.put（nums [i]，i）; &#125; for（int i = 0; i &lt;nums.length; i ++）&#123; int temp = target - nums [i]; if（map.containsKey（temp）&amp;&amp; map.get（temp）！= i）&#123; return new int [] &#123;i，map.get（temp）&#125;; &#125; &#125; 抛出新的IllegalArgumentException（“No two sum solution”）; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础总结]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F11%2F23%2FJavaSE%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1. 面向对象和面向过程的区别面向过程优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展 面向对象优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点： 性能比面向过程低 2. Java 语言有哪些特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 3. 什么是 JDK 什么是 JRE 什么是 JVM 三者之间的联系与区别这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。 JDK: JDK（Java Development Kit）顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。 JRE: 普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。 JVM： 当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是 java 程序可以一次编写多处执行的原因。 区别与联系： JDK 用于开发，JRE 用于运行java程序 ； JDK 和 JRE 中都包含 JVM ； JVM 是 java 编程语言的核心并且具有平台独立性。 4. 什么是字节码 采用字节码的最大好处是什么先看下 java 中的编译器和解释器： Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。 编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。 每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了 Java 的编译与解释并存的特点。 Java 源代码—-&gt;编译器—-&gt;jvm 可执行的 Java 字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm 中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 采用字节码的好处： Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。——百度百科 5. Java和C++的区别我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理机制，不需要程序员手动释放无用内存 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 7. Java 应用程序与小程序之间有那些差别简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 8. 字符型常量和字符串常量的区别 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占2个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节) java编程思想第四版：2.2.2节 9. 构造器 Constructor 是否可被 override在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 Constructor 也就不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。 10. 重载和重写的区别重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。 11. Java 面向对象编程三大特性:封装、继承、多态封装封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 12. String 和 StringBuffer、StringBuilder 的区别是什么 String 为什么是不可变的可变性 简单的来说：String 类中使用 final 关键字字符数组保存字符串，private final char value[]，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。 StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。 AbstractStringBuilder.java 12345678abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125; 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结： 操作少量的数据 = String 单线程操作字符串缓冲区下操作大量数据 = StringBuilder 多线程操作字符串缓冲区下操作大量数据 = StringBuffer 13. 自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； 14. 在一个静态方法内调用一个非静态成员为什么是非法的由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 15. 在 Java 中定义一个不做事且没有参数的构造方法的作用 Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 16. import java和javax有什么区别刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。 17. 接口和抽象类的区别是什么 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法 接口中的实例变量默认是 final 类型的，而抽象类中则不一定 一个类可以实现多个接口，但最多只能实现一个抽象类 一个类实现接口的话要实现接口的所有方法，而抽象类不一定 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 18. 成员变量与局部变量的区别有那些 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰； 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。 19. 创建一个对象用什么运算符？对象实体与对象引用有何不同？new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。 20. 什么是方法的返回值？返回值在类的方法里的作用是什么？方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！ 21. 一个类的构造方法的作用是什么 若一个类没有声明构造方法，该程序能正确执行吗 为什么主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 22. 构造方法有哪些特性 名字与类名相同； 没有返回值，但不能用void声明构造函数； 生成类的对象时自动执行，无需调用。 23. 静态方法和实例方法有何不同 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制. 24. 对象的相等与指向他们的引用相等，两者有什么不同？对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。 25. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作。 26. == 与 equals(重要)== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 举个例子： 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(&quot;ab&quot;); // a 为一个引用 String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样 String aa = &quot;ab&quot;; // 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa == bb) // true System.out.println(&quot;aa==bb&quot;); if (a == b) // false，非同一对象 System.out.println(&quot;a==b&quot;); if (a.equals(b)) // true System.out.println(&quot;aEQb&quot;); if (42 == 42.0) &#123; // true System.out.println(&quot;true&quot;); &#125; &#125;&#125; 说明： String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 27. hashCode 与 equals（重要）面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode（）介绍hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode（）与equals（）的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等,对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 28. 为什么Java中只有值传递为什么Java中只有值传递？ 29. 简述线程，程序、进程的基本概念。以及他们之间关系是什么线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。 进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 30. 线程有哪些基本状态？这些状态是如何定义的? 新建(new)：新创建了一个线程对象。 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取cpu的使用权。 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有 机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： (一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放 入等待队列(waitting queue)中。 (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 (三). 其他阻塞: 运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 死亡(dead)：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。 备注： 可以用早起坐地铁来比喻这个过程： 还没起床：sleeping 起床收拾好了，随时可以坐地铁出发：Runnable 等地铁来：Waiting 地铁来了，但要排队上地铁：I/O阻塞 上了地铁，发现暂时没座位：synchronized阻塞 地铁上找到座位：Running 到达目的地：Dead 31 关于 final 关键字的一些总结final关键字主要用在三个地方：变量、方法、类。 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法。 使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。 32 Java 中的异常处理Java异常类层次结构图 在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable： 有两个重要的子类：Exception（异常） 和 Error（错误） ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。 Exception（异常）:是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 Throwable类常用方法 public string getMessage():返回异常发生时的详细信息 public string toString():返回异常发生时的简要描述 public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法，可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息 异常处理总结 try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块：用于处理try捕获到的异常。 finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。 在以下4种特殊情况下，finally块不会被执行： 在finally语句块中发生了异常。 在前面的代码中用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 33 Java序列化中如果有些字段不想进行序列化 怎么办对于不想进行序列化的变量，使用transient关键字修饰。 transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。 34 获取用键盘输入常用的的两种方法方法1：通过 Scanner 123Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); 方法2：通过 BufferedReader 12BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine();]]></content>
      <categories>
        <category>Java/J2EE基础</category>
      </categories>
      <tags>
        <tag>Java/J2EE基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建+主题优化+插件配置+常用操作+错误分析]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F11%2F23%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2B%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%2B%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE%2B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2B%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[如果你和我一样是小白，那么恭喜你！ 你马上就会有一个跟我一样的博客啦！ 博客搭建准备环境 Node.js 下载，并安装。详细步骤：www.simon96.online/2018/11/10/… Git 下载，并安装。详细步骤：www.simon96.online/2018/11/10/… 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 1234$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install复制代码 新建完成后，在路径下，会产生这些文件和文件夹： 123456789.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes复制代码 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 ​ 路径为&lt;folder&gt;\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 ​ 路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml 启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 浏览器访问网址： http://localhost:4000/ 至此，您的Hexo博客已经搭建在本地。 实施方案方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 12$ npm install hexo-deployer-git --save复制代码 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 12$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;复制代码 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@github.com$ yes复制代码 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master复制代码 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为： 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@git.coding.net$ yes复制代码 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 12345678910# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master复制代码 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 域名解析 添加 CNAME 记录指向 .coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为自定义域名； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 方案四：云服务器 + 域名该方案需要先购买云服务器和域名。 在云服务器安装Git 和 Nginx。(Git 用于版本管理和部署，Nginx 用于静态博客托管。) 登陆root用户，运行： 123$ yum -y update$ yum install -y git nginx复制代码 Nginx配置 2.1. 创建文件目录(用于博客站点文件存放) 1234cd /usr/local/mkdir hexochmod 775 -R /usr/local/hexo/复制代码 2.2. 添加 index.html(用于检测配置 Nginx 是否成功) 12vim /usr/local/hexo/index.html复制代码 添加以下代码，并保存。 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Nginx running&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;复制代码 2.3. 配置 Nginx 服务器 12vim /etc/nginx/nginx.conf复制代码 修改server_name和root： 1234567server &#123; listen 80 default_server; listen [::]:80 default_server; server_name www.baidu.com; # 填个人域名 root /usr/local/hexo/; &#125; 复制代码 2.4. 启动nginx服务； 12service nginx start复制代码 2.5. 云服务器浏览器访问个人域名或IP，若跳转index.html，则配置完成，否则检查以上配置。 git配置 3.1. 创建文件目录, 用于私人 Git 仓库搭建, 并更改目录读写权限。 1234cd /usr/local/mkdir hexoRepochmod 775 -R /usr/local/hexoRepo/复制代码 3.2. Git 初始化裸库。 123cd hexoRepo/git init --bare hexo.git复制代码 3.3. 创建 Git 钩子(hook)。 12vim /usr/local/hexoRepo/hexo.git/hooks/post-receive复制代码 3.4. 输入以下信息，用于指定 Git 的源代码 和 Git 配置文件。 1234#!/bin/bashgit --work-tree=/usr/local/hexo --git-dir=/usr/local/hexoRepo/hexo.git checkout -f复制代码 3.5. 保存并退出后, 给该文件添加可执行权限。 12chmod +x /usr/local/hexoRepo/hexo.git/hooks/post-receive复制代码 本地博客推送到云服务器 4.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 12$ npm install hexo-deployer-git --save复制代码 4.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 12$ ssh-keygen -t rsa -C &quot;邮箱地址&quot;复制代码 添加到 github。 复制密钥文件内容（路径形如C:\Users\Administrator\.ssh\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 123$ ssh -T git@github.com$ yes复制代码 4.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: root@xxx.xxx.xxx.xxx:/usr/local/hexoRepo/hexo //用户名@域名或 IP 地址:/usr/local/hexoRepo/hexo branch: master复制代码 注意：上面仓库地址写ssh地址，不写http地址。 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 123$ hexo g$ hexo d复制代码 等待1分钟左右，浏览器访问个人域名。 至此，您的Hexo博客已经搭建在云服务器, 域名为个人域名。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt;复制代码 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\themes*\layout_partials\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。 解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 12345678body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125;复制代码 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 123456789@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;);&#125;.site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important;&#125;复制代码 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 123456// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px复制代码 网站标题栏背景颜色1234.site-meta &#123; background: $blue; //修改为自己喜欢的颜色&#125;复制代码 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 12345678// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125;复制代码 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 之前插入代码： 1234567891011&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;复制代码 写文章时加上password: *： 123456---title: 2018date: 2018-10-25 16:10:03password: 123456---复制代码 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。 代码如下： 123!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);复制代码 在\themes\*\layout\_layout.swig文件末尾添加： 1234&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;复制代码 静态资源压缩在站点目录下： 12$ npm install gulp -g复制代码 安装gulp插件： 123456npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save复制代码 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]);复制代码 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 1234hexo ggulphexo d复制代码 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 12permalink: :category/:title/复制代码 博文置顶 安装插件 npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 1234567---title: 2018date: 2018-10-25 16:10:03top: 10---复制代码 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 1234567 &#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &#123;% endif %&#125;复制代码 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 123456789// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;复制代码 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 123456# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true复制代码 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 123$ cd &lt;站点目录&gt;$ hexo new page categories复制代码 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 123&#123;% include &apos;_custom/google_ad.swig&apos; %&#125;复制代码 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 12345678&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_ad.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125;复制代码 等待审核通过。如果失败，可再次申请。 添加萌萌哒 安装插件 123npm install --save hexo-helper-live2d复制代码 复制你喜欢的模型名字： Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true复制代码 建配置文件 4.1. 在站点目录下建文件夹live2d_models， 4.2. 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 4.3. 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 插件配置以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。 评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 Valine1.1. 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 1.3. 运行hexo g&amp;&amp;hexo d推送到博客。 来必力/livere2.1. 登陆 来必力 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件_config.yml 畅言3.1.获取APP ID 和 APP Key 请先登录或注册 畅言, 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的APP ID和APP Key了。 3.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 3.3. 运行hexo g&amp;&amp;hexo d推送到博客。 gitment4.1. 安装插件： npm i –save gitment 4.2. 申请应用 在New OAuth App为你的博客应用一个密钥: 123456Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址复制代码 4.3. 配置 编辑主题配置文件themes/*/_config.yml: 1234567891011121314151617# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro复制代码 Disqus编辑 主题配置文件themes/*/_config.yml， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 123456disqus: enable: false shortname: count: true复制代码 数据统计与分析 推荐指数 优点 缺点 不蒜子 4 可直接将访问次数显示在您在网页上（也可不显示） 只计数 百度统计 3 收录慢 不蒜子编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可。 当enable: true时，代表开启全局开关。 若site_uv（本站访客数）、site_pv（本站访客数）、page_pv（本文总阅读量）的值均为false时，不蒜子仅作记录而不会在页面上显示。 注意： 123不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！复制代码 解决办法： 找到主题调用不蒜子的swig文件。一般在”\themes*\layout_third-party\analytics\busuanzi-counter.swig” 更改域名 123456把原有的：&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;复制代码 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图： 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 1234# 百度分享服务baidushare: true复制代码 need-more-share2编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 1234needmoreshare2: enable: true复制代码 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 123$ npm install hexo-generator-searchdb --save复制代码 编辑 站点配置文件，新增以下内容到任意位置： 1234567search: path: search.xml field: post format: html limit: 10000复制代码 编辑 主题配置文件，启用本地搜索功能： 12345# Local searchlocal_search: enable: true复制代码 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error1234JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s复制代码 参数中包含冒号，请用加引号，如Last updated: %s 1234JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated：&quot;Last updated: %s&quot;复制代码 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” EMFILE Error123Error: EMFILE, too many open files复制代码 生成大量的文件时，可能遇到EMFILE错误。 可以运行以下命令来增加允许同步I / O操作的数量。 123$ ulimit -n 10000复制代码 Process Out of Memory当hexo g时，遇到以下错误： 123FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory复制代码 如下，更改hexo-cli文件的第一行，来增大nodejs堆内存.该bug已在新版本修复。 123#!/usr/bin/env node --max_old_space_size=8192复制代码 Git Deployment Problems RPC failed 12345error: RPC failed; result=22, HTTP code = 403fatal: &apos;username.github.io&apos; does not appear to be a git repository复制代码 确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。 Error: ENOENT: no such file or directory 这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。 解决办法： 检查文章的标签和类别,确保本地和github上是相同的。 合并分支（Commit）。 清除，重构。在站点目录下，命令行（即Git Bash）运行hexo clean和hexo g 手动将站点目录下的public文件夹复制到您的桌面 从你的master分支切换到部署在本地分支。 从桌面复制public文件夹到本地分支。 合并分支到github（Commit）。 切回master分支。 Server Problems123Error: listen EADDRINUSE复制代码 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置： 123$ hexo server -p 5000复制代码 Plugin Installation Problems123npm ERR! node-waf configure build复制代码 这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。 Error with DTrace (Mac OS X)12345&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;复制代码 DTrace安装可能有问题，重装: 123$ npm install hexo --no-optional复制代码 详见 #1326 Iterate Data Model on Jade or SwigHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。 1234&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125;复制代码 Data Not Updated一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次： 123$ hexo clean复制代码 No command is executed那个不能使用除help、init和version以外的命令行（即Git Bash）时, 有可能时站点目录下的package.json文件，缺少hexo ，如下: 1234567&#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;&#125;复制代码 Escape ContentsHexo使用Nunjucks渲染的页面. { { } }或{ % % }将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号： 1​ Hello {{ sensitive }} ​12复制代码 ENOSPC Error (Linux)如果运行命令$ hexo server 返回一个错误: 123Error: watch ENOSPC ...复制代码 可以通过运行$ npm dedupe或者以下命令行（即Git Bash）： 123$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p复制代码 来增加测试时，你可以看见的文件数量。 EMPERM Error (Windows Subsystem for Linux)如果在Windows Subsystem for Linux，运行命令$ hexo server 返回这个错误: 123Error: watch /path/to/hexo/theme/ EMPERM复制代码 因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。 所以需要重新编译，再启动服务器： 1234$ hexo generate$ hexo server -s复制代码 Template render error有时运行命令$ hexo generate 返回一个错误: 1234FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)复制代码 这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件_config.yml中，比如缩进错误： 错误例子： 12345plugins:hexo-generator-feedhexo-generator-sitemap复制代码 常用操作创建文章命令： 123$ hexo new [layout] &lt;title&gt;复制代码 参数说明： [layout]可以为以下三种： 参数名 功能 文章路径 post 新建博文 source/_posts page 新建页面（如404，分类） source draft 草稿 source/_drafts 草稿可通过一下命令发布： 123$ hexo publish [layout] &lt;title&gt;复制代码 title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://www.simon96.online/2018/10/12/hexo-tutorial/中的hexo-tutorial） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” ​ 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhaianzwh.github.io%2F2017%2F11%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
