<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/haianzwh.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/haianzwh.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/haianzwh.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/haianzwh.github.io/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/haianzwh.github.io/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/haianzwh.github.io/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/haianzwh.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="源码剖析," />










<meta name="description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); parse方法由各种Namespa">
<meta name="keywords" content="源码剖析">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-context">
<meta property="og:url" content="http://haianzwh.github.io/2018/06/12/Spring-context/index.html">
<meta property="og:site_name" content="蘸酒拭剑">
<meta property="og:description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现: 1">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/Comparator.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ContextAnnotationAutowireCandidateResolver.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ConfigurationClassPostProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/AutowiredAnnotationBeanPostProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/CommonAnnotationBeanPostProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/EventListenerMethodProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/DefaultEventListenerFactory.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/CompositeComponentDefinition.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/context_annotation_stack.png">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ImportAwareBeanPostProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/BeanNameGenerator.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/@required_test.png">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ScopeMetadataResolver.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/MetadataReader.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/AnnotationMetadataReadingVisitor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ScannedGenericBeanDefinition.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/PropertyOverrideBeanDefinitionParser.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/PropertyOverrideConfigurer.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/PropertySourcesPlaceholderConfigurer.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/LoadTimeWeaver.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/AspectJWeavingEnabler.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/AnnotationBeanConfigurerAspect.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/LoadTimeWeaverAwareProcessor.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/ClassPreProcessorAgentAdapter.jpg">
<meta property="og:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/aop_xml_parse.png">
<meta property="og:updated_time" content="2019-01-13T11:23:01.850Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring-context">
<meta name="twitter:description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现: 1">
<meta name="twitter:image" content="https://github.com/seaswalker/Spring/raw/master/note/images/Comparator.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/haianzwh.github.io/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haianzwh.github.io/2018/06/12/Spring-context/"/>





  <title>Spring-context | 蘸酒拭剑</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/haianzwh.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蘸酒拭剑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Unless i do not want to win <br> Otherwise nothing make me lose.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/haianzwh.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/haianzwh.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/haianzwh.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-日志">
          <a href="/haianzwh.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-简历">
          <a href="/haianzwh.github.io/resume" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            简历
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haianzwh.github.io/haianzwh.github.io/2018/06/12/Spring-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="haianzwh">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ws1.sinaimg.cn/large/00649eqogy1fyw15ah7hhj3021021mx0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蘸酒拭剑">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spring-context</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-12T23:44:51+08:00">
                2018-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/haianzwh.github.io/categories/源码剖析/" itemprop="url" rel="index">
                    <span itemprop="name">源码剖析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</span><br></pre></td></tr></table></figure>
<p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    return findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = this.parsers.get(localName);</span><br><span class="line">    if (parser == null) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            &quot;Cannot locate BeanDefinitionParser for element [&quot; + localName + &quot;]&quot;, element);</span><br><span class="line">    &#125;</span><br><span class="line">    return parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p>
<h1 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h1><p>AnnotationConfigBeanDefinitionParser.parse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    //返回null</span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    // Obtain bean definitions for all relevant BeanPostProcessors.</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.</span><br><span class="line">                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    // Register component for the surrounding &lt;context:annotation-config&gt; element.</span><br><span class="line">    CompositeComponentDefinition compDefinition = </span><br><span class="line">        new CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    // Nest the concrete beans in the surrounding component.</span><br><span class="line">    for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        parserContext.registerComponent(new BeanComponentDefinition(processorDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">    // Finally register the composite component.</span><br><span class="line">    // 空实现</span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h2><p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span><br><span class="line">public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors(</span><br><span class="line">        BeanDefinitionRegistry registry, Object source) &#123;</span><br><span class="line">    //将registery强转为DefaultListableBeanFactory类型</span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    if (beanFactory != null) &#123;</span><br><span class="line">        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!(beanFactory.getAutowireCandidateResolver() instanceof </span><br><span class="line">            ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4);</span><br><span class="line"></span><br><span class="line">    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span><br><span class="line">    if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span><br><span class="line">    if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition();</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h3><p>其继承体系如下:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/Comparator.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/Comparator.jpg" alt="Comparator继承体系"></a></p>
<p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p>
<p><a href="http://www.tuicool.com/articles/VnqUv2" target="_blank" rel="noopener">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p>
<h3 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h3><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ContextAnnotationAutowireCandidateResolver.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ContextAnnotationAutowireCandidateResolver.jpg" alt="ContextAnnotationAutowireCandidateResolver类图"></a></p>
<h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>此类用于处理标注了@Configuration注解的类。类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ConfigurationClassPostProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ConfigurationClassPostProcessor.jpg" alt="ConfigurationClassPostProcessor类图"></a></p>
<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/AutowiredAnnotationBeanPostProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor类图"></a></p>
<h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final boolean jsr250Present =</span><br><span class="line">    ClassUtils.isPresent(&quot;javax.annotation.Resource&quot;, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/CommonAnnotationBeanPostProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/CommonAnnotationBeanPostProcessor.jpg" alt="CommonAnnotationBeanPostProcessor类图"></a></p>
<h3 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h3><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final boolean jpaPresent =   </span><br><span class="line">    ClassUtils.isPresent(&quot;javax.persistence.EntityManagerFactory&quot;, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">    //org.springframework.orm包</span><br><span class="line">    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p>
<h3 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/EventListenerMethodProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/EventListenerMethodProcessor.jpg" alt="EventListenerMethodProcessor类图"></a></p>
<h3 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h3><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/DefaultEventListenerFactory.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/DefaultEventListenerFactory.jpg" alt="DefaultEventListenerFactory类图"></a></p>
<h2 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h2><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/CompositeComponentDefinition.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/CompositeComponentDefinition.jpg" alt="CompositeComponentDefinition类图"></a></p>
<p>最终形成的数据结构如下图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/context_annotation_stack.png" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/context_annotation_stack.png" alt="数据结构"></a></p>
<p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p>
<h4 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h4><p>此方法大体由两部分组成。</p>
<h5 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h5><p>此部分源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class);</span><br><span class="line">    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);</span><br><span class="line">    RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);</span><br><span class="line">    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ImportAwareBeanPostProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ImportAwareBeanPostProcessor.jpg" alt="ImportAwareBeanPostProcessor类图"></a></p>
<p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p>
<p>有一个类负责生成Student bean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class StudentConfig implements ImportAware &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Student student() &#123;</span><br><span class="line">        Student student = new Student();</span><br><span class="line">        student.setAge(22);</span><br><span class="line">        student.setName(&quot;skywalker&quot;);</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setImportMetadata(AnnotationMetadata importMetadata) &#123;</span><br><span class="line">        System.out.println(&quot;importaware&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(StudentConfig.class)</span><br><span class="line">public class SimpleBeanConfig &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private StudentConfig studentConfig;</span><br><span class="line">    @Bean</span><br><span class="line">    public SimpleBean getSimpleBean() &#123;</span><br><span class="line">        //bean依赖</span><br><span class="line">        SimpleBean simpleBean = new SimpleBean(studentConfig.student());</span><br><span class="line">        return simpleBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        new AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p>
<h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p>
<h5 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h5><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p>
<h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p>
<p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Detect any custom bean name generation strategy supplied through the enclosing application context</span><br><span class="line">SingletonBeanRegistry singletonRegistry = null;</span><br><span class="line">if (registry instanceof SingletonBeanRegistry) &#123;</span><br><span class="line">    singletonRegistry = (SingletonBeanRegistry) registry;</span><br><span class="line">    if (!this.localBeanNameGeneratorSet &amp;&amp; </span><br><span class="line">        //org.springframework.context.annotation.internalConfigurationBeanNameGenerator</span><br><span class="line">        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.</span><br><span class="line">            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        this.componentScanBeanNameGenerator = generator;</span><br><span class="line">        this.importBeanNameGenerator = generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/BeanNameGenerator.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/BeanNameGenerator.jpg" alt="BeanNameGenerator类图"></a></p>
<p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p>
<h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = </span><br><span class="line">        new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    //寻找@Configuration的BeanDefinition</span><br><span class="line">    for (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        // nothing to enhance -&gt; return immediately</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();</span><br><span class="line">    for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        // If a @Configuration class gets proxied, always proxy the target class</span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        // Set enhanced subclass of the user-specified bean class</span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader);</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);</span><br><span class="line">        if (configClass != enhancedClass) &#123;</span><br><span class="line">             //替换</span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurationClassEnhancer.newEnhancer:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Enhancer newEnhancer(Class&lt;?&gt; superclass, ClassLoader classLoader) &#123;</span><br><span class="line">    Enhancer enhancer = new Enhancer();</span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    //这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span><br><span class="line">    enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(false);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    //关键</span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    return enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CALLBACK_FILTER是个什么东西呢:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static final ConditionalCallbackFilter CALLBACK_FILTER = </span><br><span class="line">    new ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line">private static final Callback[] CALLBACKS = new Callback[] &#123;</span><br><span class="line">    new BeanMethodInterceptor(),</span><br><span class="line">    new BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这么做的原因有两个:</p>
<ul>
<li><p>提供Scope支持:</p>
<p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public Student student() &#123;</span><br><span class="line">  Student student = new Student();</span><br><span class="line">    student.setAge(22);</span><br><span class="line">    student.setName(&quot;skywalker&quot;);</span><br><span class="line">    return student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p>
</li>
<li><p>实现EnhancedConfiguration接口</p>
</li>
</ul>
<h3 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p>
<h4 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><h5 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h5><p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p>
<p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123;</span><br><span class="line">    // Instantiate the bean.</span><br><span class="line">    BeanWrapper instanceWrapper = null;</span><br><span class="line">    if (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (instanceWrapper == null) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);</span><br><span class="line">    // Allow post-processors to modify the merged bean definition.</span><br><span class="line">    synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">        if (!mbd.postProcessed) &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applyMergedBeanDefinitionPostProcessors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, </span><br><span class="line">    String beanName) &#123;</span><br><span class="line">    for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        if (bp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String     beanName) &#123;</span><br><span class="line">    if (beanType != null) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findAutowiringMetadata:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) &#123;</span><br><span class="line">    // Fall back to class name as cache key, for backwards compatibility with custom callers.</span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    // Quick check on the concurrent map first, with minimal locking.</span><br><span class="line">    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        synchronized (this.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = this.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                if (metadata != null) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                this.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p>
<ul>
<li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li>
<li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li>
</ul>
<p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p>
<p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = </span><br><span class="line">        new LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    //循环检测父类</span><br><span class="line">    do &#123;</span><br><span class="line">        final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                new LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                if (ann != null) &#123;</span><br><span class="line">                      //不支持静态变量</span><br><span class="line">                    if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(new AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException &#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    if (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (method.getParameterTypes().length == 0) &#123;</span><br><span class="line">                        if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(&quot;Autowired annotation should be used on </span><br><span class="line">                                methods with parameters: &quot; + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(new AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        elements.addAll(0, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    while (targetClass != null &amp;&amp; targetClass != Object.class);</span><br><span class="line">    return new InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p>
<h5 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h5><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p>
<p>ReflectionUtils的实现其实就是访问者模式，其源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void doWithLocalFields(Class&lt;?&gt; clazz, FieldCallback fc) &#123;</span><br><span class="line">    for (Field field : getDeclaredFields(clazz)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IllegalAccessException ex) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p>
<h5 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h5><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></table></figure>
<p>此句代码的作用是<strong>判断method是否是bridge方法，如果是，寻找其真正的方法。</strong>这里的bridge方法并不是所谓的bridge模式。</p>
<p>有这样的demo代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class JavaTest &#123;</span><br><span class="line">    private class MyList extends ArrayList &#123;</span><br><span class="line">        //注意父类的返回类型是Object</span><br><span class="line">        @Override</span><br><span class="line">        public String get(int index) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Method method : MyList.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(&quot;name: &quot; + method.getName() + &quot;, return: &quot; + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></table></figure>
<p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns &#123;@code true&#125; if this method is a bridge</span><br><span class="line"> * method; returns &#123;@code false&#125; otherwise.</span><br><span class="line"> *</span><br><span class="line"> * @return true if and only if this method is a bridge</span><br><span class="line"> * method as defined by the Java Language Specification.</span><br><span class="line"> * @since 1.5</span><br><span class="line"> */</span><br><span class="line">public boolean isBridge() &#123;</span><br><span class="line">    return (getModifiers() &amp; Modifier.BRIDGE) != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p>
<p>可以参考: <a href="http://ifeve.com/syntethic-and-bridge-methods/" target="_blank" rel="noopener">Java那些不为人知的特殊方法</a></p>
<p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p>
<h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p>
<h4 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><h5 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h5><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p>
<h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><p>源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void processInjection(Object bean) throws BeansException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">     // 查找缓存</span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null);</span><br><span class="line">    metadata.inject(bean, null, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p>
<h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p>
<h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p>
<h3 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p>
<h4 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>空实现，就是这么任性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String    beanName) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">    if (!this.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">        if (!shouldSkip(this.beanFactory, beanName)) &#123;</span><br><span class="line">            List&lt;String&gt; invalidProperties = new ArrayList&lt;String&gt;();</span><br><span class="line">            for (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">                if (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">                throw new BeanInitializationException(buildExceptionMessage</span><br><span class="line">                    (invalidProperties, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.validatedBeanNames.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h5><p>validatedBeanNames是一个Set类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</p>
<h5 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h5><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p>
<p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">if (hasInstAwareBpps) &#123;</span><br><span class="line">    for (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        if (bp instanceof InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            if (pvs == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            new LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    for (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123;</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        if (isExcludedFromDependencyCheck(pd)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pds.toArray(new PropertyDescriptor[pds.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p>
<p>BeanWrapperImpl.getPropertyDescriptors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">    return getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">&#125;</span><br><span class="line">private CachedIntrospectionResults getCachedIntrospectionResults() &#123;</span><br><span class="line">    Assert.state(getWrappedInstance() != null, &quot;BeanWrapper does not hold a bean instance&quot;);</span><br><span class="line">    if (this.cachedIntrospectionResults == null) &#123;</span><br><span class="line">        this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    return this.cachedIntrospectionResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>有一个bean如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;simpleBean&quot;)</span><br><span class="line">public class SimpleBean &#123;</span><br><span class="line">    @Autowired(required = false)</span><br><span class="line">    private Student student;</span><br><span class="line"></span><br><span class="line">    public SimpleBean() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public SimpleBean(Student student) &#123;</span><br><span class="line">        this.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    public Student getStudent() &#123;</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">    @Required</span><br><span class="line">    public void setStudent(Student student) &#123;</span><br><span class="line">        this.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/@required_test.png" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/@required_test.png" alt="@Required测试"></a></p>
<h3 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p>
<h4 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String     beanName) &#123;</span><br><span class="line">    super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    if (beanType != null) &#123;</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String     beanName) &#123;</span><br><span class="line">    if (beanType != null) &#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CommonAnnotationBeanPostProcessor() &#123;</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p>
<p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;initAnnotationType&quot; value=&quot;annotation.Init&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>Init是一个很简单的自定义注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">public @interface Init &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在自己的bean中使用此注解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Init</span><br><span class="line">public void init() &#123;</span><br><span class="line">    System.out.println(&quot;Init!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Spring便可以看到效果。</p>
<p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p>
<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p>
<h4 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) &#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>套路很明显了。</p>
<h4 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h4><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeInitMethods:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void invokeInitMethods(Object target, String beanName) throws Throwable &#123;</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods);</span><br><span class="line">    if (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">        for (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">             // 反射调用</span><br><span class="line">            element.invoke(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过从源码来看应该支持多个init方法。</p>
<h4 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h4><p>反射调用销毁方法，没啥说的了。</p>
<h3 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>就一个值得关注的方法: afterSingletonsInstantiated。</p>
<h5 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h5><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">        final SmartInitializingSingleton smartSingleton = </span><br><span class="line">            (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        if (System.getSecurityManager() != null) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Object run() &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>略过。</p>
<h1 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h1><p>ComponentScanBeanDefinitionParser.parse源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    // base-package属性</span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    // 解析占位符</span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment()</span><br><span class="line">        .resolvePlaceholders(basePackage);</span><br><span class="line">    //分割成数据</span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    // Actually scan for bean definitions and register them.</span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123;</span><br><span class="line">    boolean useDefaultFilters = true;</span><br><span class="line">    if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Delegate bean definition registration to scanner class.</span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner</span><br><span class="line">        (parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());</span><br><span class="line">    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line">    if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    parseBeanNameGenerator(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseScope(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    return scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始按顺序分部分说明。</p>
<h3 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h3><p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p>
<h3 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h3><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p>
<h3 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h3><p>用以配置扫描器扫描的路径，默认<code>**/*.class</code>。</p>
<h3 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h3><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p>
<h3 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h3><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ScopeMetadataResolver.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ScopeMetadataResolver.jpg" alt="ScopeMetadataResolver类图"></a></p>
<p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p>
<h3 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h3><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p>
<h3 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h3><p>用法示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;base&quot;&gt;</span><br><span class="line">    &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;javax.annotation.Resource&quot; /&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>
<p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125; else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>此属性等同于<context:annotation-config>配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</context:annotation-config></p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    for (String basePackage : basePackages) &#123;</span><br><span class="line">         // 逐包扫描</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">            if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">                 // 为BeanDefinition设置默认的属性</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations</span><br><span class="line">                    ((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode</span><br><span class="line">                    (scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h3><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/MetadataReader.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/MetadataReader.jpg" alt="MetadataReader类图"></a></p>
<p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException &#123;</span><br><span class="line">    InputStream is = new BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    classReader = new ClassReader(is);</span><br><span class="line"></span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">    this.annotationMetadata = visitor;</span><br><span class="line">    // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span><br><span class="line">    this.classMetadata = visitor;</span><br><span class="line">    this.resource = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/AnnotationMetadataReadingVisitor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/AnnotationMetadataReadingVisitor.jpg" alt="AnnotationMetadataReadingVisitor类图"></a></p>
<p>核心在于其visitAnnotation方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public AnnotationVisitor visitAnnotation(final String desc, boolean visible) &#123;</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    this.annotationSet.add(className);</span><br><span class="line">    return new AnnotationAttributesReadingVisitor(</span><br><span class="line">        className, this.attributesMap, this.metaAnnotationMap, this.classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ScannedGenericBeanDefinition.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ScannedGenericBeanDefinition.jpg" alt="ScannedGenericBeanDefinition类图"></a></p>
<h3 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h3><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ScopeMetadata resolveScopeMetadata(BeanDefinition definition) &#123;</span><br><span class="line">    ScopeMetadata metadata = new ScopeMetadata();</span><br><span class="line">    if (definition instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">         // 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), this.scopeAnnotationType);</span><br><span class="line">        if (attributes != null) &#123;</span><br><span class="line">             // @Scope值</span><br><span class="line">            metadata.setScopeName(attributes.getString(&quot;value&quot;));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(&quot;proxyMode&quot;);</span><br><span class="line">            if (proxyMode == null || proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                proxyMode = this.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxyMode和xml的scoped-proxy属性是一个概念:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scope(value = &quot;singleton&quot;, proxyMode = ScopedProxyMode.DEFAULT)</span><br></pre></td></tr></table></figure>
<p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p>
<h3 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h3><p>AnnotationBeanNameGenerator.generateBeanName:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    if (definition instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        if (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            // Explicit bean name found.</span><br><span class="line">            return beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Fallback: generate a unique default bean name.</span><br><span class="line">    return buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h4><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) &#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = null;</span><br><span class="line">     // 遍历当前bean拥有的所有类级注解</span><br><span class="line">    for (String type : types) &#123;</span><br><span class="line">         // 获取此注解所有的属性</span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">        if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class="line">            Object value = attributes.get(&quot;value&quot;);</span><br><span class="line">            if (value instanceof String) &#123;</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                if (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">                    if (beanName != null &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                        throw new IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isStereotypeWithNameValue(String annotationType,</span><br><span class="line">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">    // org.springframework.stereotype.Component</span><br><span class="line">    boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">        (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">        annotationType.equals(&quot;javax.annotation.ManagedBean&quot;) ||</span><br><span class="line">        annotationType.equals(&quot;javax.inject.Named&quot;);</span><br><span class="line">    return (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(&quot;value&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>metaAnnotationTypes用以判断元注解，针对这种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public @interface Controller &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p>
<h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protected String buildDefaultBeanName(BeanDefinition definition) &#123;</span><br><span class="line">    // base.SimpleBean -&gt; SimpleBean</span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    //SimpleBean -&gt; simpleBean</span><br><span class="line">    return Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p>
<h3 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h3><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Lazy</span><br><span class="line">@Primary</span><br><span class="line">@DependsOn(&quot;student&quot;)</span><br><span class="line">@Role(BeanDefinition.ROLE_APPLICATION)</span><br><span class="line">@Description(&quot;This is a simple bean.&quot;)</span><br><span class="line">public class SimpleBean &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p>
<h3 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h3><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) &#123;</span><br><span class="line">    // 没有同名的，直接返回</span><br><span class="line">    if (!this.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition existingDef = this.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    if (originatingDef != null) &#123;</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    &#125;</span><br><span class="line">    if (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new ConflictingBeanDefinitionException(&quot;冲突啦!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) &#123;</span><br><span class="line">    //// explicitly registered overriding bean</span><br><span class="line">    return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || </span><br><span class="line">            //// scanned same file twice</span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) || </span><br><span class="line">            // scanned equivalent class twice           </span><br><span class="line">            newDefinition.equals(existingDefinition));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p>
<h3 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h3><p>入口: ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br></pre></td></tr></table></figure>
<p>AnnotationConfigUtils.applyScopedProxyMode:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static BeanDefinitionHolder applyScopedProxyMode(</span><br><span class="line">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    // 基本都是从这里跑了</span><br><span class="line">    if (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        return definition;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p>
<ul>
<li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li>
<li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li>
<li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li>
<li>代理者和被代理者同时存在于容器中。</li>
</ul>
<p>可以看出，这其实是一个偷天换日的过程。</p>
<p>做个实验:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Boostrap &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleBean已开启代理，输出的结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61</span><br></pre></td></tr></table></figure>
<p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p>
<p>DefaultListableBeanFactory.getBean(Class requiredType, Object… args)部分源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line">//不止一个满足条件(代理者和被代理者)</span><br><span class="line">if (beanNames.length &gt; 1) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;();</span><br><span class="line">    for (String beanName : beanNames) &#123;</span><br><span class="line">         // here</span><br><span class="line">        if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (autowireCandidates.size() &gt; 0) &#123;</span><br><span class="line">        beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p>
<h3 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h3><p>你懂的。</p>
<h2 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h2><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p>
<h1 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p>
<p>定义如下的属性文件(property.properties):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.name=dog</span><br></pre></td></tr></table></figure>
<p>格式为: bean名字.属性名字=值。由如下的bean:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;student&quot; class=&quot;base.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;skywalker&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;30&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>进行如下的配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-override location=&quot;property.properties&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>运行如下的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;config.xml&quot;);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的便是dog，而不是skywalker。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/PropertyOverrideBeanDefinitionParser.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/PropertyOverrideBeanDefinitionParser.jpg" alt="PropertyOverrideBeanDefinitionParser类图"></a></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码:</p>
<p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doParse(Element element, BeanDefinitionBuilder builder) &#123;</span><br><span class="line">    String location = element.getAttribute(&quot;location&quot;);</span><br><span class="line">    if (StringUtils.hasLength(location)) &#123;</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(&quot;locations&quot;, locations);</span><br><span class="line">    &#125;</span><br><span class="line">    String propertiesRef = element.getAttribute(&quot;properties-ref&quot;);</span><br><span class="line">    if (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">        builder.addPropertyReference(&quot;properties&quot;, propertiesRef);</span><br><span class="line">    &#125;</span><br><span class="line">    String fileEncoding = element.getAttribute(&quot;file-encoding&quot;);</span><br><span class="line">    if (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;fileEncoding&quot;, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">    String order = element.getAttribute(&quot;order&quot;);</span><br><span class="line">    if (StringUtils.hasLength(order)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;order&quot;, Integer.valueOf(order));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPropertyValue(&quot;ignoreResourceNotFound&quot;,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(&quot;ignore-resource-not-found&quot;)));</span><br><span class="line">    builder.addPropertyValue(&quot;localOverride&quot;,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(&quot;local-override&quot;)));</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h3><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-override  properties-ref=&quot;property&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean id=&quot;property&quot; class=&quot;java.util.Properties&quot;&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;student.name&quot;&gt;cat&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>这样便可以看到结果。</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p>
<h3 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h3><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p>
<h3 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h3><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p>
<h3 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h3><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected Properties[] localProperties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Set local properties, e.g. via the &quot;props&quot; tag in XML bean definitions.</span><br><span class="line"> * These can be considered defaults, to be overridden by properties</span><br><span class="line"> * loaded from files.</span><br><span class="line"> */</span><br><span class="line">public void setProperties(Properties properties) &#123;</span><br><span class="line">    this.localProperties = new Properties[] &#123;properties&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-override  location=&quot;property.properties&quot; local-override=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyOverrideConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key=&quot;student.name&quot;&gt;cat&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/PropertyOverrideConfigurer.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/PropertyOverrideConfigurer.jpg" alt="PropertyOverrideConfigurer类图"></a></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">         // 属性加载</span><br><span class="line">        Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">        // Convert the merged properties, if necessary.</span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        // Let the subclass process the properties.</span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanInitializationException(&quot;Could not load properties&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><p>PropertiesLoaderSupport.mergeProperties:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected Properties mergeProperties() throws IOException &#123;</span><br><span class="line">    Properties result = new Properties();</span><br><span class="line">    if (this.localOverride) &#123;</span><br><span class="line">        // Load properties from file upfront, to let local properties override.</span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.localProperties != null) &#123;</span><br><span class="line">        for (Properties localProp : this.localProperties) &#123;</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!this.localOverride) &#123;</span><br><span class="line">        // Load properties from file afterwards, to let those properties override.</span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p>
<h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void applyPropertyValue(</span><br><span class="line">        ConfigurableListableBeanFactory factory, String beanName, String property, String value) &#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    while (bd.getOriginatingBeanDefinition() != null) &#123;</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyValue pv = new PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(this.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p>
<h1 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h1><p>这个怎么用已经喜闻乐见了</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p>
<p>PropertyPlaceholderBeanDefinitionParser.doParse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doParse(Element element, BeanDefinitionBuilder builder) &#123;</span><br><span class="line">    super.doParse(element, builder);</span><br><span class="line">    builder.addPropertyValue(&quot;ignoreUnresolvablePlaceholders&quot;,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(&quot;ignore-unresolvable&quot;)));</span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    if (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;systemPropertiesModeName&quot;, &quot;SYSTEM_PROPERTIES_MODE_&quot;</span><br><span class="line">            + systemPropertiesModeName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (element.hasAttribute(&quot;value-separator&quot;)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;valueSeparator&quot;, element.getAttribute(&quot;value-separator&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (element.hasAttribute(&quot;trim-values&quot;)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;trimValues&quot;, element.getAttribute(&quot;trim-values&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    if (element.hasAttribute(&quot;null-value&quot;)) &#123;</span><br><span class="line">        builder.addPropertyValue(&quot;nullValue&quot;, element.getAttribute(&quot;null-value&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h3><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p>
<h3 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h3><p>用于配置默认的值的分隔符:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;student&quot; class=&quot;base.Student&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;$&#123;student.name:skywalker&#125;&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p>
<h3 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h3><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p>
<h3 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h3><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p>
<h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/PropertySourcesPlaceholderConfigurer.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/PropertySourcesPlaceholderConfigurer.jpg" alt="PropertySourcesPlaceholderConfigurer类图"></a></p>
<h2 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h2><p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    if (this.propertySources == null) &#123;</span><br><span class="line">        this.propertySources = new MutablePropertySources();</span><br><span class="line">        if (this.environment != null) &#123;</span><br><span class="line">            this.propertySources.addLast(</span><br><span class="line">                new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, </span><br><span class="line">                    this.environment) &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public String getProperty(String key) &#123;</span><br><span class="line">                        return this.source.getProperty(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">        if (this.localOverride) &#123;</span><br><span class="line">            this.propertySources.addFirst(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            this.propertySources.addLast(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources));</span><br><span class="line">    this.appliedPropertySources = this.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p>
<p>不使用property-placeholder标签，以显式的bean定义代替。</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p>
<h1 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h1><p>这两个配置是紧密相关的，所以在一起说了。</p>
<p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p>
<p>可以参考:</p>
<p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">Spring之LoadTimeWeaver——一个需求引发的思考</a></p>
<p><a href="http://www.iteye.com/topic/481813" target="_blank" rel="noopener">Spring LoadTimeWeaver 的那些事儿</a></p>
<h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p>
<p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p>
<p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p>
<p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge nt</p>
<p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InstrumentationSavingAgent &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    public static void premain(String agentArgs, Instrumentation inst) &#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Instrumentation getInstrumentation() &#123;</span><br><span class="line">        return instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p>
<h3 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h3><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/LoadTimeWeaver.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/LoadTimeWeaver.jpg" alt="LoadTimeWeaver继承体系"></a></p>
<p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected String getBeanClassName(Element element) &#123;</span><br><span class="line">    // 如果配置了weaver-class属性，那么使用其值</span><br><span class="line">    if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        return element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line">    // org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span><br><span class="line">    return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个BeanDefinition的id/name又是什么呢?</p>
<p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext    parserContext) &#123;</span><br><span class="line">    // loadTimeWeaver</span><br><span class="line">    return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p>
<h3 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h3><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) &#123;</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">        if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">            RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">        if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">            new SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h3><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p>
<p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p>
<h3 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h3><p>isAspectJWeavingEnabled方法用于判断是否启用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) &#123;</span><br><span class="line">    if (&quot;on&quot;.equals(value)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125; else if (&quot;off&quot;.equals(value)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 寻找aop.xml</span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();</span><br><span class="line">        return (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h3><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/AspectJWeavingEnabler.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/AspectJWeavingEnabler.jpg" alt="AspectJWeavingEnabler类图"></a></p>
<h3 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h3><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());</span><br></pre></td></tr></table></figure>
<p>其parse方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">    // org.springframework.context.config.internalBeanConfigurerAspect</span><br><span class="line">    if (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = new RootBeanDefinition();</span><br><span class="line">         // org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(&quot;aspectOf&quot;);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(new BeanComponentDefinition</span><br><span class="line">            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/AnnotationBeanConfigurerAspect.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/AnnotationBeanConfigurerAspect.jpg" alt="AnnotationBeanConfigurerAspect类图"></a></p>
<p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p>
<p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p>
<p>语法可以参考:</p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点详解</a></p>
<h4 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h4><h5 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h5><p>在AnnotationBeanConfigurerAspect中定义，源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public pointcut inConfigurableBean() : @this(Configurable);</span><br></pre></td></tr></table></figure>
<p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p>
<h5 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h5><p>源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public pointcut beanConstruction(Object bean) :</span><br><span class="line">            initialization(ConfigurableObject+.new(..)) &amp;&amp; this(bean);</span><br></pre></td></tr></table></figure>
<p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p>
<h5 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private pointcut preConstructionCondition() :</span><br><span class="line">            leastSpecificSuperTypeConstruction() &amp;&amp; preConstructionConfiguration();</span><br></pre></td></tr></table></figure>
<p>由两个pointcut与运算而来。</p>
<h5 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..));</span><br></pre></td></tr></table></figure>
<h5 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);</span><br><span class="line">private pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) &amp;&amp; if (c.preConstruction());</span><br></pre></td></tr></table></figure>
<p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p>
<h5 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private pointcut postConstructionCondition() :</span><br><span class="line">            mostSpecificSubTypeConstruction() &amp;&amp; !preConstructionConfiguration();</span><br></pre></td></tr></table></figure>
<p>mostSpecificSubTypeConstruction:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public pointcut mostSpecificSubTypeConstruction() :</span><br><span class="line">            if (thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></table></figure>
<p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p>
<h4 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h4><h5 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  &#123;</span><br><span class="line">    configureBean(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h2><p>AspectJWeavingEnabler.postProcessBeanFactory:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enableAspectJWeaving:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void enableAspectJWeaving(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader) &#123;</span><br><span class="line">    // 不为空</span><br><span class="line">    if (weaverToUse == null) &#123;</span><br><span class="line">        if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">            weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;No LoadTimeWeaver available&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h3><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p>
<p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// loadTimeWeaver</span><br><span class="line">if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    // Set a temporary ClassLoader for type matching.</span><br><span class="line">    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/LoadTimeWeaverAwareProcessor.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/LoadTimeWeaverAwareProcessor.jpg" alt="LoadTimeWeaverAwareProcessor类图"></a></p>
<p>postProcessBeforeInitialization方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object postProcessBeforeInitialization(Object bean, String beanName) &#123;</span><br><span class="line">    if (bean instanceof LoadTimeWeaverAware) &#123;</span><br><span class="line">        LoadTimeWeaver ltw = this.loadTimeWeaver;</span><br><span class="line">        if (ltw == null) &#123;</span><br><span class="line">            Assert.state(this.beanFactory != null,</span><br><span class="line">                &quot;BeanFactory required if no LoadTimeWeaver explicitly specified&quot;);</span><br><span class="line">             // 去容器找 </span><br><span class="line">            ltw = this.beanFactory.getBean(</span><br><span class="line">                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        &#125;</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    &#125;</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p>
<p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p>
<p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p>
<p>AbstractApplicationContext.refresh:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Invoke factory processors registered as beans in the context.</span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">// Register bean processors that intercept bean creation.</span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p>
<p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) &#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        if (result == null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBeanPostProcessors:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() &#123;</span><br><span class="line">    return this.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></table></figure>
<p>直接将实例添加到BeanFactory中，所以可以得出结论:</p>
<p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p>
<h3 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h3><h4 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h4><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p>
<p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">    if (bean instanceof Aware) &#123;</span><br><span class="line">        if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h4><p>这个方法很关键，对instrument的获取就是在这里。源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    if (serverSpecificLoadTimeWeaver != null) &#123;</span><br><span class="line">        this.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    &#125; else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">        this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显分为三部分。</p>
<h5 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h5><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>createServerSpecificLoadTimeWeaver源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) &#123;</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    if (name.startsWith(&quot;weblogic&quot;)) &#123;</span><br><span class="line">        return new WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; else if (name.startsWith(&quot;org.glassfish&quot;)) &#123;</span><br><span class="line">        return new GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; else if (name.startsWith(&quot;org.apache.catalina&quot;)) &#123;</span><br><span class="line">        return new TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; else if (name.startsWith(&quot;org.jboss&quot;)) &#123;</span><br><span class="line">        return new JBossLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; else if (name.startsWith(&quot;com.ibm&quot;)) &#123;</span><br><span class="line">        return new WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p>
<p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p>
<h5 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h5><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isInstrumentationAvailable() &#123;</span><br><span class="line">    return (getInstrumentation() != null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Instrumentation getInstrumentation() &#123;</span><br><span class="line">    if (AGENT_CLASS_PRESENT) &#123;</span><br><span class="line">        return InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p>
<p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class InstrumentationAccessor &#123;</span><br><span class="line">    public static Instrumentation getInstrumentation() &#123;</span><br><span class="line">        return InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ReflectiveLoadTimeWeaver() &#123;</span><br><span class="line">    this(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReflectiveLoadTimeWeaver(ClassLoader classLoader) &#123;</span><br><span class="line">    Assert.notNull(classLoader, &quot;ClassLoader must not be null&quot;);</span><br><span class="line">    this.classLoader = classLoader;</span><br><span class="line">    this.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            this.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    if (this.addTransformerMethod == null) &#123;</span><br><span class="line">        throw new IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p>
<p><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" target="_blank" rel="noopener">Chapter 5. Load-Time Weaving</a></p>
<h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p>
<p>AspectJClassBypassingClassFileTransformer.transform:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123;</span><br><span class="line">    // aspectj自身的类无需检测(织入)，直接跳过</span><br><span class="line">    if (className.startsWith(&quot;org.aspectj&quot;) || className.startsWith(&quot;org/aspectj&quot;)) &#123;</span><br><span class="line">        return classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.delegate.transform(loader, className, classBeingRedefined, </span><br><span class="line">        protectionDomain, classfileBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/ClassPreProcessorAgentAdapter.jpg" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/ClassPreProcessorAgentAdapter.jpg" alt="ClassPreProcessorAgentAdapter类图"></a></p>
<p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p>
<h3 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h3><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p>
<h4 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h4><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p>
<h5 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h5><h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p>
<p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;aspectj&gt;</span><br><span class="line">    &lt;aspects&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;/&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect&quot;/&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;/&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect&quot;/&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.cache.aspectj.AnnotationCacheAspect&quot;/&gt;</span><br><span class="line">        &lt;aspect name=&quot;org.springframework.cache.aspectj.JCacheCacheAspect&quot;/&gt;</span><br><span class="line">    &lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure>
<p>那么解析后的结果:</p>
<p><a href="https://github.com/seaswalker/Spring/blob/master/note/images/aop_xml_parse.png" target="_blank" rel="noopener"><img src="https://github.com/seaswalker/Spring/raw/master/note/images/aop_xml_parse.png" alt="aop.xml解析结果"></a></p>
<h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List&lt;Definition&gt; definitions) &#123;</span><br><span class="line">    //对应&lt;weaver options=&quot;-verbose&quot;&gt;</span><br><span class="line">    registerOptions(weaver, loader, definitions);</span><br><span class="line">    //对应&lt;exclude&gt;标签</span><br><span class="line">    registerAspectExclude(weaver, loader, definitions);</span><br><span class="line">    //对应&lt;include&gt;标签</span><br><span class="line">    registerAspectInclude(weaver, loader, definitions);</span><br><span class="line">    // &lt;aspect&gt;</span><br><span class="line">    success = registerAspects(weaver, loader, definitions);</span><br><span class="line">    registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">    //对应&lt;dump&gt;标签</span><br><span class="line">    registerDump(weaver, loader, definitions);</span><br><span class="line">    //忽略返回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="https://ws1.sinaimg.cn/large/00649eqogy1fyw6fyl7gbj30fk0f6wfl.jpg" alt="haianzwh wechat" style="width: 200px; max-width: 100%;"/>
    <div></div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://ws1.sinaimg.cn/large/00649eqogy1fyw1ic1wv3j30bj0bq3z7.jpg" alt="haianzwh 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="https://ws1.sinaimg.cn/large/00649eqogy1fyw1m49s06j309309974r.jpg" alt="haianzwh 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    haianzwh
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://haianzwh.github.io/2018/06/12/Spring-context/" title="Spring-context">http://haianzwh.github.io/2018/06/12/Spring-context/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/haianzwh.github.io/tags/源码剖析/" rel="tag"># 源码剖析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/haianzwh.github.io/2018/06/12/Spring-transaction/" rel="next" title="Spring-transaction">
                <i class="fa fa-chevron-left"></i> Spring-transaction
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/haianzwh.github.io/2018/06/14/Spring-task/" rel="prev" title="Spring-task">
                Spring-task <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
 <div id="gitalk-container"></div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://ws1.sinaimg.cn/large/00649eqogy1fyw15ah7hhj3021021mx0.jpg"
                alt="haianzwh" />
            
              <p class="site-author-name" itemprop="name">haianzwh</p>
              <p class="site-description motion-element" itemprop="description">每一步做到极致 <br> 下一步美好自然呈现</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/haianzwh.github.io/archives">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/haianzwh.github.io/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/haianzwh.github.io/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/haianzwh" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                 <a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:(function() {
    function c() {
        var e = document.createElement("link");
        e.setAttribute("type", "text/css");
        e.setAttribute("rel", "stylesheet");
        e.setAttribute("href", f);
        e.setAttribute("class", l);
        document.body.appendChild(e)
    }

    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t < e.length; t++) {
            document.body.removeChild(e[t])
        }
    }

    function p() {
        var e = document.createElement("div");
        e.setAttribute("class", a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }

    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }

    function v(i) {
        var s = d(i);
        return s.height > e && s.height < n && s.width > t && s.width < r
    }

    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }

    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e && !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }

    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }

    function E(e) {
        var t = m(e);
        return t >= w && t <= b + w
    }

    function S() {
        var e = document.createElement("audio");
        e.setAttribute("class", l);
        e.src = i;
        e.loop = false;
        e.addEventListener("canplay", function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e < O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener("ended", function() {
            N();
            h()
        }, true);
        e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
        document.body.appendChild(e);
        e.play()
    }

    function x(e) {
        e.className += " " + s + " " + o
    }

    function T(e) {
        e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
    }

    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp("\\b" + s + "\\b");
        for (var n = 0; n < e.length; ) {
            e[n].className = e[n].className.replace(t, "")
        }
    }

    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
    var s = "mw-harlem_shake_me";
    var o = "im_first";
    var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
    var a = "mw-strobe_light";
    var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
    var l = "mw_added_css";
    var b = g();
    var w = y();
    var C = document.getElementsByTagName("*");
    var k = null;
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn("Could not find a node of the right size. Please try a different page.");
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
})()'><i class="fa fa-music"></i> High</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="haianzwh@gmail.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                 <a title="收藏到书签，偶尔High一下^_^" rel="alternate" class="mw-harlem_shake_slow wobble shake" href='javascript:(function() {
    function c() {
        var e = document.createElement("link");
        e.setAttribute("type", "text/css");
        e.setAttribute("rel", "stylesheet");
        e.setAttribute("href", f);
        e.setAttribute("class", l);
        document.body.appendChild(e)
    }

    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t < e.length; t++) {
            document.body.removeChild(e[t])
        }
    }

    function p() {
        var e = document.createElement("div");
        e.setAttribute("class", a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }

    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }

    function v(i) {
        var s = d(i);
        return s.height > e && s.height < n && s.width > t && s.width < r
    }

    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }

    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e && !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }

    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }

    function E(e) {
        var t = m(e);
        return t >= w && t <= b + w
    }

    function S() {
        var e = document.createElement("audio");
        e.setAttribute("class", l);
        e.src = i;
        e.loop = false;
        e.addEventListener("canplay", function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e < O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener("ended", function() {
            N();
            h()
        }, true);
        e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
        document.body.appendChild(e);
        e.play()
    }

    function x(e) {
        e.className += " " + s + " " + o
    }

    function T(e) {
        e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
    }

    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp("\\b" + s + "\\b");
        for (var n = 0; n < e.length; ) {
            e[n].className = e[n].className.replace(t, "")
        }
    }

    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3";
    var s = "mw-harlem_shake_me";
    var o = "im_first";
    var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
    var a = "mw-strobe_light";
    var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
    var l = "mw_added_css";
    var b = g();
    var w = y();
    var C = document.getElementsByTagName("*");
    var k = null;
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn("Could not find a node of the right size. Please try a different page.");
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L < C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
})()'><i class="fa fa-music"></i> High</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://haofly.net" title="精通各种语言全栈攻城狮豪豪" target="_blank">精通各种语言全栈攻城狮豪豪</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://tanjiangfu.github.io" title="精通运维兼开发攻城狮贱贱" target="_blank">精通运维兼开发攻城狮贱贱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://lqstone.github.io" title="精通前端开发攻城狮巧巧" target="_blank">精通前端开发攻城狮巧巧</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ycllang.github.io/" title="live in Happyness" target="_blank">live in Happyness</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#开头"><span class="nav-number">1.</span> <span class="nav-text">开头</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#annotation-config"><span class="nav-number">2.</span> <span class="nav-text">annotation-config</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BeanPostProcessor注册"><span class="nav-number">2.1.</span> <span class="nav-text">BeanPostProcessor注册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AnnotationAwareOrderComparator"><span class="nav-number">2.1.1.</span> <span class="nav-text">AnnotationAwareOrderComparator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContextAnnotationAutowireCandidateResolver"><span class="nav-number">2.1.2.</span> <span class="nav-text">ContextAnnotationAutowireCandidateResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationClassPostProcessor"><span class="nav-number">2.1.3.</span> <span class="nav-text">ConfigurationClassPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutowiredAnnotationBeanPostProcessor"><span class="nav-number">2.1.4.</span> <span class="nav-text">AutowiredAnnotationBeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequiredAnnotationBeanPostProcessor"><span class="nav-number">2.1.5.</span> <span class="nav-text">RequiredAnnotationBeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonAnnotationBeanPostProcessor"><span class="nav-number">2.1.6.</span> <span class="nav-text">CommonAnnotationBeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PersistenceAnnotationBeanPostProcessor"><span class="nav-number">2.1.7.</span> <span class="nav-text">PersistenceAnnotationBeanPostProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventListenerMethodProcessor"><span class="nav-number">2.1.8.</span> <span class="nav-text">EventListenerMethodProcessor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DefaultEventListenerFactory"><span class="nav-number">2.1.9.</span> <span class="nav-text">DefaultEventListenerFactory</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑关系整理"><span class="nav-number">2.2.</span> <span class="nav-text">逻辑关系整理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行"><span class="nav-number">2.3.</span> <span class="nav-text">运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationClassPostProcessor-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">ConfigurationClassPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessBeanDefinitionRegistry"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">postProcessBeanDefinitionRegistry</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanPostProcessor注册-1"><span class="nav-number">2.3.1.1.1.</span> <span class="nav-text">BeanPostProcessor注册</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ImportAwareBeanPostProcessor"><span class="nav-number">2.3.1.1.1.1.</span> <span class="nav-text">ImportAwareBeanPostProcessor</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#EnhancedConfigurationBeanPostProcessor"><span class="nav-number">2.3.1.1.1.2.</span> <span class="nav-text">EnhancedConfigurationBeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#类解析"><span class="nav-number">2.3.1.1.2.</span> <span class="nav-text">类解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#bean名字生成策略"><span class="nav-number">2.3.1.1.2.1.</span> <span class="nav-text">bean名字生成策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessBeanFactory"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">postProcessBeanFactory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AutowiredAnnotationBeanPostProcessor-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">AutowiredAnnotationBeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessMergedBeanDefinition"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">postProcessMergedBeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#入口"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">入口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源码"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变量扫描"><span class="nav-number">2.3.2.1.3.</span> <span class="nav-text">变量扫描</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法扫描"><span class="nav-number">2.3.2.1.4.</span> <span class="nav-text">方法扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#bridge方法"><span class="nav-number">2.3.2.1.4.1.</span> <span class="nav-text">bridge方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#PropertyDescriptor"><span class="nav-number">2.3.2.1.4.2.</span> <span class="nav-text">PropertyDescriptor</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessPropertyValues"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">postProcessPropertyValues</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#入口-1"><span class="nav-number">2.3.2.2.1.</span> <span class="nav-text">入口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注入"><span class="nav-number">2.3.2.2.2.</span> <span class="nav-text">注入</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Field注入"><span class="nav-number">2.3.2.2.2.1.</span> <span class="nav-text">Field注入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#方法注入"><span class="nav-number">2.3.2.2.2.2.</span> <span class="nav-text">方法注入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequiredAnnotationBeanPostProcessor-1"><span class="nav-number">2.3.3.</span> <span class="nav-text">RequiredAnnotationBeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessMergedBeanDefinition-1"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">postProcessMergedBeanDefinition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessPropertyValues-1"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">postProcessPropertyValues</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#结果缓存"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">结果缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PropertyDescriptor-1"><span class="nav-number">2.3.3.2.2.</span> <span class="nav-text">PropertyDescriptor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#测试"><span class="nav-number">2.3.3.2.3.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommonAnnotationBeanPostProcessor-1"><span class="nav-number">2.3.4.</span> <span class="nav-text">CommonAnnotationBeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessMergedBeanDefinition-2"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">postProcessMergedBeanDefinition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#父类"><span class="nav-number">2.3.4.1.1.</span> <span class="nav-text">父类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#子类"><span class="nav-number">2.3.4.1.2.</span> <span class="nav-text">子类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessPropertyValues-2"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">postProcessPropertyValues</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessBeforeInitialization"><span class="nav-number">2.3.4.3.</span> <span class="nav-text">postProcessBeforeInitialization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#postProcessBeforeDestruction"><span class="nav-number">2.3.4.4.</span> <span class="nav-text">postProcessBeforeDestruction</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventListenerMethodProcessor-1"><span class="nav-number">2.3.5.</span> <span class="nav-text">EventListenerMethodProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#入口-2"><span class="nav-number">2.3.5.0.1.</span> <span class="nav-text">入口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源码-1"><span class="nav-number">2.3.5.0.2.</span> <span class="nav-text">源码</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#component-scan"><span class="nav-number">3.</span> <span class="nav-text">component-scan</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">3.1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#use-default-filters"><span class="nav-number">3.1.1.</span> <span class="nav-text">use-default-filters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扫描器-创建-amp-初始化"><span class="nav-number">3.1.2.</span> <span class="nav-text">扫描器:创建 & 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#resource-pattern"><span class="nav-number">3.1.3.</span> <span class="nav-text">resource-pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#name-generator"><span class="nav-number">3.1.4.</span> <span class="nav-text">name-generator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scope-resolver"><span class="nav-number">3.1.5.</span> <span class="nav-text">scope-resolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scoped-proxy"><span class="nav-number">3.1.6.</span> <span class="nav-text">scoped-proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exclude-filter-include-filter"><span class="nav-number">3.1.7.</span> <span class="nav-text">exclude-filter/include-filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#annotation-config-1"><span class="nav-number">3.1.8.</span> <span class="nav-text">annotation-config</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扫描"><span class="nav-number">3.2.</span> <span class="nav-text">扫描</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逐包扫描-BeanDefinition解析"><span class="nav-number">3.2.1.</span> <span class="nav-text">逐包扫描/BeanDefinition解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scope解析"><span class="nav-number">3.2.2.</span> <span class="nav-text">@Scope解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean名字生成"><span class="nav-number">3.2.3.</span> <span class="nav-text">bean名字生成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#根据注解"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">根据注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#默认策略"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">默认策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它注解解析"><span class="nav-number">3.2.4.</span> <span class="nav-text">其它注解解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冲突检测"><span class="nav-number">3.2.5.</span> <span class="nav-text">冲突检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理生成"><span class="nav-number">3.2.6.</span> <span class="nav-text">代理生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinition注册"><span class="nav-number">3.2.7.</span> <span class="nav-text">BeanDefinition注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Component注册"><span class="nav-number">3.3.</span> <span class="nav-text">Component注册</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#property-override"><span class="nav-number">4.</span> <span class="nav-text">property-override</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作用"><span class="nav-number">4.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图"><span class="nav-number">4.2.</span> <span class="nav-text">类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析"><span class="nav-number">4.3.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#properties-ref"><span class="nav-number">4.3.1.</span> <span class="nav-text">properties-ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#order"><span class="nav-number">4.3.2.</span> <span class="nav-text">order</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ignore-resource-not-found"><span class="nav-number">4.3.3.</span> <span class="nav-text">ignore-resource-not-found</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ignore-unresolvable"><span class="nav-number">4.3.4.</span> <span class="nav-text">ignore-unresolvable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#local-override"><span class="nav-number">4.3.5.</span> <span class="nav-text">local-override</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinition"><span class="nav-number">4.3.6.</span> <span class="nav-text">BeanDefinition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行-1"><span class="nav-number">4.4.</span> <span class="nav-text">运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性加载"><span class="nav-number">4.4.1.</span> <span class="nav-text">属性加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性转换"><span class="nav-number">4.4.2.</span> <span class="nav-text">属性转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性设置"><span class="nav-number">4.4.3.</span> <span class="nav-text">属性设置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#property-placeholder"><span class="nav-number">5.</span> <span class="nav-text">property-placeholder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解析-1"><span class="nav-number">5.1.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#system-properties-mode"><span class="nav-number">5.1.1.</span> <span class="nav-text">system-properties-mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#value-separator"><span class="nav-number">5.1.2.</span> <span class="nav-text">value-separator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#null-value"><span class="nav-number">5.1.3.</span> <span class="nav-text">null-value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trim-values"><span class="nav-number">5.1.4.</span> <span class="nav-text">trim-values</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanDefinition-1"><span class="nav-number">5.1.5.</span> <span class="nav-text">BeanDefinition</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行-2"><span class="nav-number">5.2.</span> <span class="nav-text">运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理"><span class="nav-number">5.2.1.</span> <span class="nav-text">处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#load-time-weaver-amp-spring-configured"><span class="nav-number">6.</span> <span class="nav-text">load-time-weaver & spring-configured</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#javaagent"><span class="nav-number">6.1.</span> <span class="nav-text">javaagent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解析-2"><span class="nav-number">6.2.</span> <span class="nav-text">解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LoadTimeWeaver"><span class="nav-number">6.2.1.</span> <span class="nav-text">LoadTimeWeaver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LoadTimeWeaverBeanDefinitionParser"><span class="nav-number">6.2.2.</span> <span class="nav-text">LoadTimeWeaverBeanDefinitionParser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aspectj-weaving"><span class="nav-number">6.2.3.</span> <span class="nav-text">aspectj-weaving</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否开启"><span class="nav-number">6.2.4.</span> <span class="nav-text">是否开启</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AspectJWeavingEnabler"><span class="nav-number">6.2.5.</span> <span class="nav-text">AspectJWeavingEnabler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringConfiguredBeanDefinitionParser"><span class="nav-number">6.2.6.</span> <span class="nav-text">SpringConfiguredBeanDefinitionParser</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#切点-pointcut"><span class="nav-number">6.2.6.1.</span> <span class="nav-text">切点(pointcut)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#inConfigurableBean"><span class="nav-number">6.2.6.1.1.</span> <span class="nav-text">inConfigurableBean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#beanConstruction"><span class="nav-number">6.2.6.1.2.</span> <span class="nav-text">beanConstruction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preConstructionCondition"><span class="nav-number">6.2.6.1.3.</span> <span class="nav-text">preConstructionCondition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#leastSpecificSuperTypeConstruction"><span class="nav-number">6.2.6.1.4.</span> <span class="nav-text">leastSpecificSuperTypeConstruction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preConstructionConfiguration"><span class="nav-number">6.2.6.1.5.</span> <span class="nav-text">preConstructionConfiguration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#postConstructionCondition"><span class="nav-number">6.2.6.1.6.</span> <span class="nav-text">postConstructionCondition</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#advise"><span class="nav-number">6.2.6.2.</span> <span class="nav-text">advise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#前置"><span class="nav-number">6.2.6.2.1.</span> <span class="nav-text">前置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运行-3"><span class="nav-number">6.3.</span> <span class="nav-text">运行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LoadTimeWeaverAware"><span class="nav-number">6.3.1.</span> <span class="nav-text">LoadTimeWeaverAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanClassLoaderAware"><span class="nav-number">6.3.2.</span> <span class="nav-text">BeanClassLoaderAware</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#入口-3"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setBeanClassLoader"><span class="nav-number">6.3.2.2.</span> <span class="nav-text">setBeanClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#服务器agent"><span class="nav-number">6.3.2.2.1.</span> <span class="nav-text">服务器agent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-agent"><span class="nav-number">6.3.2.2.2.</span> <span class="nav-text">Spring agent</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反射"><span class="nav-number">6.3.2.2.3.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">6.3.2.2.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassFileTransformer"><span class="nav-number">6.3.3.</span> <span class="nav-text">ClassFileTransformer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Aj"><span class="nav-number">6.3.4.</span> <span class="nav-text">Aj</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WeavingAdaptor初始化"><span class="nav-number">6.3.4.2.</span> <span class="nav-text">WeavingAdaptor初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#aop-xml"><span class="nav-number">6.3.4.2.1.</span> <span class="nav-text">aop.xml</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#解析-3"><span class="nav-number">6.3.4.2.1.1.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#注册"><span class="nav-number">6.3.4.2.1.2.</span> <span class="nav-text">注册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">6.3.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">haianzwh</span>
  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/haianzwh.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/haianzwh.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/haianzwh.github.io/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/haianzwh.github.io/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/haianzwh.github.io/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/haianzwh.github.io/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/haianzwh.github.io/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/haianzwh.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  













  
  
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script>

  
  
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.css"/>

  
  
  <script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script>

 


  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'cd0069b0b40c322f7a01',
          clientSecret: '1dc259144561fb634c3e346e64f8e2e1e23b7656',
          repo: 'haianzwh.github.io',
          owner: 'haianzwh',
          admin: ['haianzwh'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/haianzwh.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>




  
  
  
  <link rel="stylesheet" href="/haianzwh.github.io/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/haianzwh.github.io/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/haianzwh.github.io/js/src/algolia-search.js?v=5.1.3"></script>



  

  

  
  

  

  

  

  
    <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
<script src="/haianzwh.github.io/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
